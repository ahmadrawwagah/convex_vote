"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var registration_impl_exports = {};
__export(registration_impl_exports, {
  actionGeneric: () => actionGeneric,
  httpEndpointGeneric: () => httpEndpointGeneric,
  internalActionGeneric: () => internalActionGeneric,
  internalMutationGeneric: () => internalMutationGeneric,
  internalQueryGeneric: () => internalQueryGeneric,
  mutationGeneric: () => mutationGeneric,
  queryGeneric: () => queryGeneric
});
module.exports = __toCommonJS(registration_impl_exports);
var import_values = require("../../values/index.js");
var import_actions_impl = require("./actions_impl.js");
var import_authentication_impl = require("./authentication_impl.js");
var import_database_impl = require("./database_impl.js");
var import_http_impl = require("./http_impl.js");
var import_query_impl = require("./query_impl.js");
var import_scheduler_impl = require("./scheduler_impl.js");
var import_storage_impl = require("./storage_impl.js");
async function invokeMutation(func, argsStr) {
  const args = (0, import_values.jsonToConvex)(JSON.parse(argsStr));
  const mutationCtx = {
    db: (0, import_database_impl.setupWriter)(),
    auth: (0, import_authentication_impl.setupAuth)(),
    storage: (0, import_storage_impl.setupStorageWriter)(),
    scheduler: (0, import_scheduler_impl.setupMutationScheduler)()
  };
  const result = await Promise.resolve(func(mutationCtx, ...args));
  validateReturnValue(result);
  return JSON.stringify((0, import_values.convexToJson)(result === void 0 ? null : result));
}
function validateReturnValue(v) {
  if (v instanceof import_query_impl.QueryInitializerImpl || v instanceof import_query_impl.QueryImpl) {
    throw new Error(
      "Return value is a Query. Results must be retrieved with `.collect()`, `.take(n), `.unique()`, or `.first()`."
    );
  }
}
const mutationGeneric = (func) => {
  const m = func;
  if (m.isRegistered) {
    throw new Error("Function registered twice " + func);
  }
  m.isRegistered = true;
  m.isMutation = true;
  m.isPublic = true;
  m.invokeMutation = (argsStr) => invokeMutation(func, argsStr);
  return m;
};
const internalMutationGeneric = (func) => {
  const m = func;
  if (m.isRegistered) {
    throw new Error("Function registered twice " + func);
  }
  m.isRegistered = true;
  m.isMutation = true;
  m.isInternal = true;
  m.invokeMutation = (argsStr) => invokeMutation(func, argsStr);
  return m;
};
async function invokeQuery(func, argsStr) {
  const args = (0, import_values.jsonToConvex)(JSON.parse(argsStr));
  const queryCtx = {
    db: (0, import_database_impl.setupReader)(),
    auth: (0, import_authentication_impl.setupAuth)(),
    storage: (0, import_storage_impl.setupStorageReader)()
  };
  const result = await Promise.resolve(func(queryCtx, ...args));
  validateReturnValue(result);
  return JSON.stringify((0, import_values.convexToJson)(result === void 0 ? null : result));
}
const queryGeneric = (func) => {
  const q = func;
  if (q.isRegistered) {
    throw new Error("Function registered twice " + func);
  }
  q.isRegistered = true;
  q.isQuery = true;
  q.isPublic = true;
  q.invokeQuery = (argsStr) => invokeQuery(func, argsStr);
  return q;
};
const internalQueryGeneric = (func) => {
  const q = func;
  if (q.isRegistered) {
    throw new Error("Function registered twice " + func);
  }
  q.isRegistered = true;
  q.isQuery = true;
  q.isInternal = true;
  q.invokeQuery = (argsStr) => invokeQuery(func, argsStr);
  return q;
};
async function invokeAction(func, requestId, argsStr) {
  const args = (0, import_values.jsonToConvex)(JSON.parse(argsStr));
  const databaseClient = (0, import_actions_impl.setupActionDatabaseClient)(requestId);
  const ctx = {
    runQuery: databaseClient.runQuery,
    runMutation: databaseClient.runMutation,
    auth: (0, import_authentication_impl.setupActionAuth)(requestId),
    scheduler: (0, import_scheduler_impl.setupActionScheduler)(requestId)
  };
  const result = await Promise.resolve(func(ctx, ...args));
  return JSON.stringify((0, import_values.convexToJson)(result === void 0 ? null : result));
}
const actionGeneric = (func) => {
  const q = func;
  if (q.isRegistered) {
    throw new Error("Function registered twice " + func);
  }
  q.isRegistered = true;
  q.isAction = true;
  q.isPublic = true;
  q.invokeAction = (requestId, argsStr) => invokeAction(func, requestId, argsStr);
  return q;
};
const internalActionGeneric = (func) => {
  const q = func;
  if (q.isRegistered) {
    throw new Error("Function registered twice " + func);
  }
  q.isRegistered = true;
  q.isAction = true;
  q.isInternal = true;
  q.invokeAction = (requestId, argsStr) => invokeAction(func, requestId, argsStr);
  return q;
};
async function invokeHttpEndpoint(func, request) {
  const calls = (0, import_http_impl.setupHttpCalls)();
  const ctx = {
    ...calls,
    auth: (0, import_authentication_impl.setupAuth)(),
    storage: (0, import_storage_impl.setupStorageHttpWriter)()
  };
  return await Promise.resolve(func(ctx, request));
}
const httpEndpointGeneric = (func) => {
  const q = func;
  if (q.isRegistered) {
    throw new Error("Function registered twice " + func);
  }
  q.isRegistered = true;
  q.isHttp = true;
  q.invokeHttpEndpoint = (request) => invokeHttpEndpoint(func, request);
  return q;
};
//# sourceMappingURL=registration_impl.js.map
