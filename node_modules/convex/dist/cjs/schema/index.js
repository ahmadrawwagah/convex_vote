"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var schema_exports = {};
__export(schema_exports, {
  SchemaDefinition: () => SchemaDefinition,
  SchemaType: () => SchemaType,
  TableDefinition: () => TableDefinition,
  defineSchema: () => defineSchema,
  defineTable: () => defineTable,
  s: () => s
});
module.exports = __toCommonJS(schema_exports);
var import_values2 = require("../values/values.js");
class SchemaType {
  constructor(type, optional, referencedTableNames = /* @__PURE__ */ new Set()) {
    this.jsonSchemaType = type;
    this.optional = optional;
    this.referencedTableNames = referencedTableNames;
  }
}
const s = {
  id(tableName) {
    return new SchemaType(
      { type: "id", tableName },
      false,
      /* @__PURE__ */ new Set([tableName])
    );
  },
  null() {
    return new SchemaType({ type: "null" }, false);
  },
  number() {
    return new SchemaType({ type: "number" }, false);
  },
  bigint() {
    return new SchemaType({ type: "bigint" }, false);
  },
  boolean() {
    return new SchemaType({ type: "boolean" }, false);
  },
  string() {
    return new SchemaType({ type: "string" }, false);
  },
  bytes() {
    return new SchemaType({ type: "bytes" }, false);
  },
  literal(literal) {
    const value = (0, import_values2.convexToJson)(literal);
    return new SchemaType({ type: "literal", value }, false);
  },
  array(values) {
    return new SchemaType(
      { type: "array", value: values.jsonSchemaType },
      false,
      values.referencedTableNames
    );
  },
  set(values) {
    return new SchemaType(
      { type: "set", value: values.jsonSchemaType },
      false,
      values.referencedTableNames
    );
  },
  map(keys, values) {
    return new SchemaType(
      {
        type: "map",
        keys: keys.jsonSchemaType,
        values: values.jsonSchemaType
      },
      false,
      /* @__PURE__ */ new Set([...keys.referencedTableNames, ...values.referencedTableNames])
    );
  },
  object(schema) {
    const referencedTableNames = /* @__PURE__ */ new Set();
    for (const schemaType of Object.values(schema)) {
      for (const tableName of schemaType.referencedTableNames) {
        referencedTableNames.add(tableName);
      }
    }
    return new SchemaType(
      {
        type: "object",
        value: Object.fromEntries(
          Object.entries(schema).map(([k, v]) => [
            k,
            { jsonSchemaType: v.jsonSchemaType, optional: v.optional }
          ])
        )
      },
      false,
      referencedTableNames
    );
  },
  union(...schemaTypes) {
    const referencedTableNames = /* @__PURE__ */ new Set();
    for (const schemaType of schemaTypes) {
      for (const tableName of schemaType.referencedTableNames) {
        referencedTableNames.add(tableName);
      }
    }
    return new SchemaType(
      {
        type: "union",
        value: schemaTypes.map((t) => t.jsonSchemaType)
      },
      false,
      referencedTableNames
    );
  },
  any() {
    return new SchemaType({ type: "any" }, false);
  },
  optional(inner) {
    return new SchemaType(
      inner.jsonSchemaType,
      true,
      inner.referencedTableNames
    );
  }
};
class TableDefinition {
  constructor(documentType) {
    this.indexes = [];
    this.searchIndexes = [];
    this.documentType = documentType;
  }
  index(name, fields) {
    this.indexes.push({ indexDescriptor: name, fields });
    return this;
  }
  searchIndex(name, indexConfig) {
    this.searchIndexes.push({
      indexDescriptor: name,
      searchField: indexConfig.searchField,
      filterFields: indexConfig.filterFields || []
    });
    return this;
  }
  export() {
    return {
      indexes: this.indexes,
      searchIndexes: this.searchIndexes,
      referencedTableNames: this.documentType.referencedTableNames,
      documentType: JSON.stringify(this.documentType.jsonSchemaType)
    };
  }
}
function defineTable(documentSchema) {
  if (documentSchema instanceof SchemaType) {
    return new TableDefinition(documentSchema);
  } else {
    return new TableDefinition(s.object(documentSchema));
  }
}
class SchemaDefinition {
  constructor(tables, options) {
    this.tables = tables;
    this.isStrict = !!options?.strict;
    this.exportDocumentType = !!options?.exportDocumentType;
  }
  export() {
    const tableNames = new Set(Object.keys(this.tables));
    return JSON.stringify({
      tables: Object.entries(this.tables).map(([tableName, definition]) => {
        const { indexes, searchIndexes, referencedTableNames, documentType } = definition.export();
        for (const referencedTableName of referencedTableNames) {
          if (!tableNames.has(referencedTableName)) {
            throw new Error(
              `SchemaValidationError: Table ${tableName} has a \`s.id\` expression that references table ${referencedTableName} which isn't defined in the schema.`
            );
          }
        }
        if (this.exportDocumentType) {
          return {
            tableName,
            indexes,
            searchIndexes,
            documentType
          };
        } else {
          return {
            tableName,
            indexes,
            searchIndexes
          };
        }
      })
    });
  }
}
function defineSchema(schema, options) {
  return new SchemaDefinition(schema, options);
}
//# sourceMappingURL=index.js.map
