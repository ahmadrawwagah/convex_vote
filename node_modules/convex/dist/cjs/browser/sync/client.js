"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var client_exports = {};
__export(client_exports, {
  InternalConvexClient: () => InternalConvexClient
});
module.exports = __toCommonJS(client_exports);
var import__ = require("../../index.js");
var import_values = require("../../values/index.js");
var import_logging = require("../logging.js");
var import_local_state = require("./local_state.js");
var import_request_manager = require("./request_manager.js");
var import_optimistic_updates_impl = require("./optimistic_updates_impl.js");
var import_remote_query_set = require("./remote_query_set.js");
var import_udf_path_utils = require("./udf_path_utils.js");
var import_web_socket_manager = require("./web_socket_manager.js");
var import_session = require("./session.js");
class InternalConvexClient {
  constructor(address, onTransition, options) {
    this.fetchToken = null;
    if (typeof address === "object") {
      throw new Error(
        "Passing a ClientConfig object is no longer supported. Pass the URL of the Convex deployment as a string directly."
      );
    }
    options = { ...options };
    let webSocketConstructor = options.webSocketConstructor;
    if (!webSocketConstructor && typeof WebSocket === "undefined") {
      throw new Error(
        "No WebSocket global variable defined! To use Convex in an environment without WebSocket try the HTTP client: https://docs.convex.dev/api/classes/browser.ConvexHttpClient"
      );
    }
    webSocketConstructor = webSocketConstructor || WebSocket;
    const verbose = options.verbose ?? false;
    const i = address.search("://");
    if (i === -1) {
      throw new Error("Provided address was not an absolute URL.");
    }
    const origin = address.substring(i + 3);
    const protocol = address.substring(0, i);
    let wsProtocol;
    if (protocol === "http") {
      wsProtocol = "ws";
    } else if (protocol === "https") {
      wsProtocol = "wss";
    } else {
      throw new Error(`Unknown parent protocol ${protocol}`);
    }
    const wsUri = `${wsProtocol}://${origin}/api/${import__.version}/sync`;
    this.state = new import_local_state.LocalSyncState();
    this.remoteQuerySet = new import_remote_query_set.RemoteQuerySet(
      (queryId) => this.state.queryPath(queryId)
    );
    this.requestManager = new import_request_manager.RequestManager();
    this.optimisticQueryResults = new import_optimistic_updates_impl.OptimisticQueryResults();
    this.onTransition = onTransition;
    this.nextRequestId = 0;
    this.sessionId = (0, import_session.newSessionId)();
    const { unsavedChangesWarning } = options;
    if (typeof window === "undefined") {
      if (unsavedChangesWarning === true) {
        throw new Error(
          "unsavedChangesWarning requested, but no window object found! Remove {unsavedChangesWarning: true} from Convex client options."
        );
      }
    } else if (unsavedChangesWarning !== false) {
      window.addEventListener("beforeunload", (e) => {
        if (this.requestManager.hasIncompleteRequests()) {
          e.preventDefault();
          const confirmationMessage = "Are you sure you want to leave? Your changes may not be saved.";
          (e || window.event).returnValue = confirmationMessage;
          return confirmationMessage;
        }
      });
    }
    this.webSocketManager = new import_web_socket_manager.WebSocketManager(
      wsUri,
      (reconnectMetadata) => {
        this.webSocketManager.sendMessage({
          ...reconnectMetadata,
          type: "Connect",
          sessionId: this.sessionId
        });
        this.remoteQuerySet = new import_remote_query_set.RemoteQuerySet(
          (queryId) => this.state.queryPath(queryId)
        );
        const [querySetModification, authModification] = this.state.restart();
        if (authModification) {
          this.webSocketManager.sendMessage(authModification);
        }
        this.webSocketManager.sendMessage(querySetModification);
        for (const message of this.requestManager.restart()) {
          this.webSocketManager.sendMessage(message);
        }
      },
      (serverMessage) => {
        switch (serverMessage.type) {
          case "Transition": {
            this.remoteQuerySet.transition(serverMessage);
            this.state.saveQueryJournals(serverMessage);
            const completedRequests = this.requestManager.removeCompleted(
              this.remoteQuerySet.timestamp()
            );
            this.notifyOnQueryResultChanges(completedRequests);
            break;
          }
          case "MutationResponse": {
            const completedMutationId = this.requestManager.onResponse(serverMessage);
            if (completedMutationId) {
              this.notifyOnQueryResultChanges(/* @__PURE__ */ new Set([completedMutationId]));
            }
            break;
          }
          case "ActionResponse": {
            this.requestManager.onResponse(serverMessage);
            break;
          }
          case "AuthError": {
            this.tryToReauthenticate(serverMessage).then().catch((error) => {
              (0, import_logging.logFatalError)(error);
              void this.webSocketManager.stop();
            });
            break;
          }
          case "FatalError": {
            const error = (0, import_logging.logFatalError)(serverMessage.error);
            void this.webSocketManager.stop();
            throw error;
          }
          case "Ping":
            break;
          default: {
            const _typeCheck = serverMessage;
          }
        }
      },
      webSocketConstructor,
      verbose
    );
  }
  notifyOnQueryResultChanges(completedRequest) {
    const remoteQueryResults = this.remoteQuerySet.remoteQueryResults();
    const queryTokenToValue = /* @__PURE__ */ new Map();
    for (const [queryId, result] of remoteQueryResults) {
      const queryToken = this.state.queryToken(queryId);
      if (queryToken !== null) {
        const query = {
          result,
          udfPath: this.state.queryPath(queryId),
          args: this.state.queryArgs(queryId)
        };
        queryTokenToValue.set(queryToken, query);
      }
    }
    this.onTransition(
      this.optimisticQueryResults.ingestQueryResultsFromServer(
        queryTokenToValue,
        completedRequest
      )
    );
  }
  async setAuth(fetchToken) {
    this.fetchToken = fetchToken;
    const token = await fetchToken();
    if (token) {
      this.authenticate(token);
    } else if (this.state.hasAuth()) {
      this.clearAuth();
    }
  }
  async tryToReauthenticate(serverMessage) {
    if (!this.fetchToken) {
      throw new Error(serverMessage.error);
    }
    console.log("Attempting to reauthenticate");
    await this.webSocketManager.pause();
    const token = await this.fetchToken();
    if (token && this.state.isNewAuth(token)) {
      this.state.setAuth(token);
    } else if (this.state.hasAuth()) {
      console.log("Reauthentication failed, clearing auth");
      this.state.clearAuth();
    }
    await this.webSocketManager.resume();
  }
  hasAuth() {
    return this.state.hasAuth();
  }
  authenticate(token) {
    const message = this.state.setAuth(token);
    this.webSocketManager.sendMessage(message);
  }
  setAdminAuth(value, fakeUserIdentity) {
    const message = this.state.setAdminAuth(value, fakeUserIdentity);
    this.webSocketManager.sendMessage(message);
  }
  clearAuth() {
    const message = this.state.clearAuth();
    this.webSocketManager.sendMessage(message);
  }
  subscribe(name, args, journal) {
    if (!Array.isArray(args)) {
      throw new Error(
        `Query arguments to \`InternalConvexClient.subcribe\` must be an array. Received ${args}.`
      );
    }
    const { modification, queryToken, unsubscribe } = this.state.subscribe(
      name,
      args,
      journal
    );
    if (modification !== null) {
      this.webSocketManager.sendMessage(modification);
    }
    return {
      queryToken,
      unsubscribe: () => {
        const modification2 = unsubscribe();
        if (modification2) {
          this.webSocketManager.sendMessage(modification2);
        }
      }
    };
  }
  localQueryResult(udfPath, args) {
    const queryToken = (0, import_udf_path_utils.serializePathAndArgs)(udfPath, args);
    return this.optimisticQueryResults.queryResult(queryToken);
  }
  queryJournal(name, args) {
    const queryToken = (0, import_udf_path_utils.serializePathAndArgs)(name, args);
    return this.state.queryJournal(queryToken);
  }
  connectionState() {
    return {
      hasInflightRequests: this.requestManager.hasInflightRequests(),
      isWebSocketConnected: this.webSocketManager.socketState() === "ready"
    };
  }
  async mutate(udfPath, args, optimisticUpdate = null) {
    const requestId = this.nextRequestId;
    this.nextRequestId++;
    if (optimisticUpdate !== null) {
      const wrappedUpdate = (localQueryStore) => {
        optimisticUpdate(localQueryStore, ...args);
      };
      const changedQueries = this.optimisticQueryResults.applyOptimisticUpdate(
        wrappedUpdate,
        requestId
      );
      this.onTransition(changedQueries);
    }
    const message = {
      type: "Mutation",
      requestId,
      udfPath,
      args: (0, import_values.convexToJson)(args)
    };
    const mightBeSent = this.webSocketManager.sendMessage(message);
    return this.requestManager.request(message, mightBeSent);
  }
  async action(udfPath, args) {
    const requestId = this.nextRequestId;
    this.nextRequestId++;
    const message = {
      type: "Action",
      requestId,
      udfPath,
      args: (0, import_values.convexToJson)(args)
    };
    const mightBeSent = this.webSocketManager.sendMessage(message);
    return this.requestManager.request(message, mightBeSent);
  }
  async close() {
    return this.webSocketManager.stop();
  }
}
//# sourceMappingURL=client.js.map
