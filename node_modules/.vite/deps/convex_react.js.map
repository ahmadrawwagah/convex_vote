{
  "version": 3,
  "sources": ["../../base64-js/index.js", "../../convex/src/index.ts", "../../convex/src/values/values.ts", "../../convex/src/browser/logging.ts", "../../convex/src/browser/sync/udf_path_utils.ts", "../../convex/src/browser/sync/local_state.ts", "../../convex/src/browser/sync/request_manager.ts", "../../convex/src/browser/sync/optimistic_updates_impl.ts", "../../convex/src/browser/long.ts", "../../convex/src/browser/sync/remote_query_set.ts", "../../convex/src/browser/sync/protocol.ts", "../../convex/src/browser/sync/web_socket_manager.ts", "../../convex/src/browser/sync/session.ts", "../../convex/src/browser/sync/client.ts", "../../convex/src/browser/http_client.ts", "../../convex/src/react/index.ts", "../../convex/src/react/use_subscription.ts", "../../convex/src/react/use_paginated_query.ts", "../../convex/src/react/use_queries.ts", "../../convex/src/react/queries_observer.ts", "../../convex/src/react/use_upload.ts", "../../convex/src/react/ConvexAuthState.tsx", "../../convex/src/react/auth_helpers.ts"],
  "sourcesContent": ["'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n", "export const version = \"0.12.2\";\n", "/**\n * Utilities for working with values stored in Convex.\n *\n * You can see the full set of supported types at\n * [Types](https://docs.convex.dev/using/types).\n * @module\n */\nimport * as Base64 from \"base64-js\";\n\nconst LITTLE_ENDIAN = true;\n// This code is used by code that may not have bigint literals.\nconst MIN_INT64 = BigInt(\"-9223372036854775808\");\nconst MAX_INT64 = BigInt(\"9223372036854775807\");\nconst ZERO = BigInt(\"0\");\nconst EIGHT = BigInt(\"8\");\nconst TWOFIFTYSIX = BigInt(\"256\");\n\n/**\n * The type of JavaScript values serializable to JSON.\n *\n * @public\n */\nexport type JSONValue =\n  | null\n  | boolean\n  | number\n  | string\n  | JSONValue[]\n  | { [key: string]: JSONValue };\n\n/**\n * An identifier for a document in Convex.\n *\n * Convex documents are uniquely identified by their `Id`, which is accessible\n * on the `_id` field. To learn more, see [Data Modeling](https://docs.convex.dev/using/data-modeling).\n *\n * Documents can be loaded using `db.get(id)` in query and mutation functions.\n *\n * **Important**: Use `myId.equals(otherId)` to check for equality.\n * Using `===` will not work because two different instances of `Id` can refer\n * to the same document.\n *\n * `Id`s are 17 bytes long and consist of:\n * - A 15-byte random value.\n * - A 2-byte timestamp representing the document's creation, in days since the Unix epoch.\n * This is encoded in base 62 ([0-9A-Za-z]).\n *\n * If you're using code generation, use the `Id` class typed for your data model in\n * `convex/_generated/dataModel.js`.\n *\n * @typeParam TableName - A string literal type of the table name (like \"users\").\n *\n * @public\n */\nexport class Id<TableName extends string> {\n  /**\n   * The table name this {@link GenericId} references.\n   */\n  public readonly tableName: TableName;\n\n  /**\n   * The identifier string.\n   *\n   * This contains the characters `[0-9A-Za-z]`.\n   */\n  public readonly id: string;\n\n  constructor(tableName: TableName, id: string) {\n    this.tableName = tableName;\n    this.id = id;\n  }\n\n  /**\n   * Check if this {@link GenericId} refers to the same document as another {@link GenericId}.\n   *\n   * @param other - The other {@link GenericId} to compare to.\n   * @returns `true` if the objects refer to the same document.\n   */\n  equals(other: unknown): boolean {\n    if (other instanceof Id) {\n      return this.tableName === other.tableName && this.id === other.id;\n    }\n    return false;\n  }\n\n  /**\n   * Parse a {@link GenericId} from its JSON representation.\n   */\n  static fromJSON(obj: any): Id<string> {\n    if (typeof obj.$id !== \"string\") {\n      throw new Error(\n        `Object ${JSON.stringify(obj)} isn't a valid Id: $id isn't a string.`\n      );\n    }\n    const parts = obj.$id.split(\"|\");\n    if (parts.length !== 2) {\n      throw new Error(\n        `Object ${JSON.stringify(obj)} isn't a valid Id: Wrong number of parts.`\n      );\n    }\n    return new Id(parts[0], parts[1]);\n  }\n\n  /**\n   * Convert a {@link GenericId} into its JSON representation.\n   */\n  toJSON(): JSONValue {\n    const idString = `${this.tableName}|${this.id}`;\n    return { $id: idString };\n  }\n\n  /**\n   * Convert a {@link GenericId} into its string representation.\n   *\n   * This includes the identifier but not the table name.\n   */\n  toString(): string {\n    return this.id;\n  }\n\n  /**\n   * Pretty-print this {@link GenericId} for debugging.\n   */\n  inspect(): string {\n    return `Id('${this.tableName}', '${this.id}')`;\n  }\n}\n\n/**\n * Internal type used in Convex code generation.\n *\n * @public\n */\nexport type GenericIdConstructor<TableNames extends string> = {\n  new <TableName extends TableNames>(\n    tableName: TableName,\n    id: string\n  ): Id<TableName>;\n  prototype: Id<string>;\n  fromJSON(obj: any): Id<string>;\n};\n\n/**\n * A value supported by Convex.\n *\n * Values can be:\n * - stored inside of documents.\n * - used as arguments and return types to queries and mutation functions.\n *\n * You can see the full set of supported types at\n * [Types](https://docs.convex.dev/using/types).\n *\n * @public\n */\nexport type Value =\n  | Id<string>\n  | null\n  | bigint\n  | number\n  | boolean\n  | string\n  | ArrayBuffer\n  | Value[]\n  | Set<Value>\n  | Map<Value, Value>\n  | { [key: string]: undefined | Value };\n\n/**\n * The types of {@link Value} that can be used to represent numbers.\n *\n * @public\n */\nexport type NumericValue = bigint | number;\n\nfunction isSpecial(n: number) {\n  return Number.isNaN(n) || !Number.isFinite(n) || Object.is(n, -0);\n}\n\nexport function slowBigIntToBase64(value: bigint): string {\n  // the conversion is easy if we pretend it's unsigned\n  if (value < ZERO) {\n    value -= MIN_INT64 + MIN_INT64;\n  }\n  let hex = value.toString(16);\n  if (hex.length % 2 === 1) hex = \"0\" + hex;\n\n  const bytes = new Uint8Array(new ArrayBuffer(8));\n  let i = 0;\n  for (const hexByte of hex.match(/.{2}/g)!.reverse()) {\n    bytes.set([parseInt(hexByte, 16)], i++);\n    value >>= EIGHT;\n  }\n  return Base64.fromByteArray(bytes);\n}\n\nexport function slowBase64ToBigInt(encoded: string): bigint {\n  const integerBytes = Base64.toByteArray(encoded);\n  if (integerBytes.byteLength !== 8) {\n    throw new Error(\n      `Received ${integerBytes.byteLength} bytes, expected 8 for $integer`\n    );\n  }\n  let value = ZERO;\n  let power = ZERO;\n  for (const byte of integerBytes) {\n    value += BigInt(byte) * TWOFIFTYSIX ** power;\n    power++;\n  }\n  if (value > MAX_INT64) {\n    value += MIN_INT64 + MIN_INT64;\n  }\n  return value;\n}\n\nexport function modernBigIntToBase64(value: bigint): string {\n  if (value < MIN_INT64 || MAX_INT64 < value) {\n    throw new Error(\n      `BigInt ${value} does not fit into a 64-bit signed integer.`\n    );\n  }\n  const buffer = new ArrayBuffer(8);\n  new DataView(buffer).setBigInt64(0, value, true);\n  return Base64.fromByteArray(new Uint8Array(buffer));\n}\n\nexport function modernBase64ToBigInt(encoded: string): bigint {\n  const integerBytes = Base64.toByteArray(encoded);\n  if (integerBytes.byteLength !== 8) {\n    throw new Error(\n      `Received ${integerBytes.byteLength} bytes, expected 8 for $integer`\n    );\n  }\n  const intBytesView = new DataView(integerBytes.buffer);\n  return intBytesView.getBigInt64(0, true);\n}\n\n// Fall back to a slower version on Safari 14 which lacks these APIs.\nexport const bigIntToBase64 = (DataView.prototype as any).setBigInt64\n  ? modernBigIntToBase64\n  : slowBigIntToBase64;\nexport const base64ToBigInt = (DataView.prototype as any).getBigInt64\n  ? modernBase64ToBigInt\n  : slowBase64ToBigInt;\n\nconst MAX_IDENTIFIER_LEN = 64;\nconst ALL_UNDERSCORES = /^_+$/;\nconst IDENTIFIER_REGEX = /^[a-zA-Z_][a-zA-Z0-9_]{0,63}$/;\n\nfunction validateObjectField(k: string) {\n  if (k.length === 0) {\n    throw new Error(\"Empty field names are disallowed.\");\n  }\n  if (k.length > MAX_IDENTIFIER_LEN) {\n    throw new Error(\n      `Field name ${k} exceeds maximum field name length ${MAX_IDENTIFIER_LEN}.`\n    );\n  }\n  if (k.startsWith(\"$\")) {\n    throw new Error(`Field name ${k} starts with a '$', which is reserved.`);\n  }\n  if (ALL_UNDERSCORES.test(k)) {\n    throw new Error(`Field name ${k} can't exclusively be underscores.`);\n  }\n  if (!IDENTIFIER_REGEX.test(k)) {\n    throw new Error(\n      `Field name ${k} must only contain alphanumeric characters or underscores and can't start with a number.`\n    );\n  }\n}\n\nfunction jsonToConvexInternal(value: JSONValue): Value {\n  if (value === null) {\n    return value;\n  }\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  if (typeof value === \"number\") {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if (value instanceof Array) {\n    return value.map(jsonToConvexInternal);\n  }\n  if (typeof value !== \"object\") {\n    throw new Error(`Unexpected type of ${value}`);\n  }\n  const entries = Object.entries(value);\n  if (entries.length === 1) {\n    const key = entries[0][0];\n    if (key === \"$id\" || key === \"$weakRef\" || key === \"$strongRef\") {\n      return Id.fromJSON(value);\n    }\n    if (key === \"$bytes\") {\n      if (typeof value.$bytes !== \"string\") {\n        throw new Error(`Malformed $bytes field on ${value}`);\n      }\n      return Base64.toByteArray(value.$bytes).buffer;\n    }\n    if (key === \"$integer\") {\n      if (typeof value.$integer !== \"string\") {\n        throw new Error(`Malformed $integer field on ${value}`);\n      }\n      return base64ToBigInt(value.$integer);\n    }\n    if (key === \"$float\") {\n      if (typeof value.$float !== \"string\") {\n        throw new Error(`Malformed $float field on ${value}`);\n      }\n      const floatBytes = Base64.toByteArray(value.$float);\n      if (floatBytes.byteLength !== 8) {\n        throw new Error(\n          `Received ${floatBytes.byteLength} bytes, expected 8 for $float`\n        );\n      }\n      const floatBytesView = new DataView(floatBytes.buffer);\n      const float = floatBytesView.getFloat64(0, LITTLE_ENDIAN);\n      if (!isSpecial(float)) {\n        throw new Error(`Float ${float} should be encoded as a number`);\n      }\n      return float;\n    }\n    if (key === \"$set\") {\n      if (!(value.$set instanceof Array)) {\n        throw new Error(`Malformed $set field on ${value}`);\n      }\n      return new Set(value.$set.map(jsonToConvexInternal));\n    }\n    if (key === \"$map\") {\n      if (!(value.$map instanceof Array)) {\n        throw new Error(`Malformed $map field on ${value}`);\n      }\n      const map = new Map();\n      for (const pair of value.$map) {\n        if (!(pair instanceof Array) || pair.length !== 2) {\n          throw new Error(`Malformed pair in $map ${value}`);\n        }\n        const k = jsonToConvexInternal(pair[0]);\n        const v = jsonToConvexInternal(pair[1]);\n        map.set(k, v);\n      }\n      return map;\n    }\n  }\n  const out: { [key: string]: Value } = {};\n  for (const [k, v] of Object.entries(value)) {\n    validateObjectField(k);\n    out[k] = jsonToConvexInternal(v);\n  }\n  return out;\n}\n\n/**\n * Parse a Convex value from its JSON representation.\n *\n * This function will revive classes like {@link GenericId} that have been serialized to JSON, parse out `BigInt`s, and so on.\n *\n * To learn more about Convex values, see [Types](https://docs.convex.dev/using/types).\n *\n * @param value - The JSON representation of a Convex value previously created with {@link convexToJson}.\n * @returns The JavaScript representation of the Convex value.\n *\n * @public\n */\nexport function jsonToConvex(value: JSONValue): Value {\n  return jsonToConvexInternal(value);\n}\n\nfunction stringifyValueForError(value: any) {\n  return JSON.stringify(value, (_key, value) => {\n    if (value === undefined) {\n      // By default `JSON.stringify` will serialize `undefined` to `null` which\n      // produces a confusing error message. Use `\"undefined\"` instead.\n      // Ideally we'd use a pretty-printing library that prints `undefined`\n      // (no quotes), but it might not be worth the bundle size cost.\n      return \"undefined\";\n    }\n    return value;\n  });\n}\n\nfunction convexToJsonInternal(\n  value: Value,\n  originalValue: Value,\n  context: string\n): JSONValue {\n  if (value === undefined) {\n    const contextText =\n      context &&\n      ` (present at path ${context} in original object ${stringifyValueForError(\n        originalValue\n      )})`;\n    throw new Error(\n      `undefined is not a valid Convex value${contextText}. To learn about Convex's supported types, see https://docs.convex.dev/using/types.`\n    );\n  }\n  if (value === null) {\n    return value;\n  }\n  if (value instanceof Id) {\n    return value.toJSON();\n  }\n  if (typeof value === \"bigint\") {\n    if (value < MIN_INT64 || MAX_INT64 < value) {\n      throw new Error(\n        `BigInt ${value} does not fit into a 64-bit signed integer.`\n      );\n    }\n    return { $integer: bigIntToBase64(value) };\n  }\n  if (typeof value === \"number\") {\n    if (isSpecial(value)) {\n      const buffer = new ArrayBuffer(8);\n      new DataView(buffer).setFloat64(0, value, LITTLE_ENDIAN);\n      return { $float: Base64.fromByteArray(new Uint8Array(buffer)) };\n    } else {\n      return value;\n    }\n  }\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if (value instanceof ArrayBuffer) {\n    return { $bytes: Base64.fromByteArray(new Uint8Array(value)) };\n  }\n  if (value instanceof Array) {\n    return value.map((value, i) =>\n      convexToJsonInternal(value, originalValue, context + `[${i}]`)\n    );\n  }\n  if (value instanceof Set) {\n    return {\n      $set: [...value].map((value, i) =>\n        convexToJsonInternal(value, originalValue, context + `.keys()[${i}]`)\n      ),\n    };\n  }\n  if (value instanceof Map) {\n    return {\n      $map: [...value].map(([k, v], i) => {\n        const jsonKey = convexToJsonInternal(\n          k,\n          originalValue,\n          context + `.keys()[${i}]`\n        );\n        const jsonValue = convexToJsonInternal(\n          v,\n          originalValue,\n          context + `.values()[${i}]`\n        );\n        return [jsonKey, jsonValue];\n      }),\n    };\n  }\n\n  const isObject = typeof value === \"object\";\n  const prototype = Object.getPrototypeOf(value);\n  const isSimple = prototype === null || prototype === Object.prototype;\n  if (!isObject || !isSimple) {\n    const theType = value?.constructor?.name;\n    const typeMsg = theType ? `${theType} ` : \"\";\n    if (context) {\n      throw new Error(\n        `${typeMsg}${stringifyValueForError(\n          value\n        )} is not a supported Convex type (present at path ${context} in original object ${stringifyValueForError(\n          originalValue\n        )}). To learn about Convex's supported types, see https://docs.convex.dev/using/types.`\n      );\n    } else {\n      throw new Error(\n        `${typeMsg}${stringifyValueForError(\n          value\n        )} is not a supported Convex type.`\n      );\n    }\n  }\n\n  const out: { [key: string]: JSONValue } = {};\n  for (const [k, v] of Object.entries(value)) {\n    if (v !== undefined) {\n      validateObjectField(k);\n      out[k] = convexToJsonInternal(v, originalValue, context + `.${k}`);\n    }\n  }\n  return out;\n}\n\n/**\n * Convert a Convex value to its JSON representation.\n *\n * Use {@link jsonToConvex} to recreate the original value.\n *\n * To learn more about Convex values, see [Types](https://docs.convex.dev/using/types).\n *\n * @param value - A Convex value to convert into JSON.\n * @returns The JSON representation of `value`.\n *\n * @public\n */\nexport function convexToJson(value: Value): JSONValue {\n  return convexToJsonInternal(value, value, \"\");\n}\n", "// This is blue #9 from https://www.radix-ui.com/docs/colors/palette-composition/the-scales\n// It must look good in both light and dark mode.\nconst INFO_COLOR = \"color:rgb(0, 145, 255)\";\n\nexport type UdfType = \"query\" | \"mutation\" | \"action\";\n\nfunction prefix_for_source(source: UdfType) {\n  switch (source) {\n    case \"query\":\n      return \"Q\";\n    case \"mutation\":\n      return \"M\";\n    case \"action\":\n      return \"A\";\n  }\n}\n\nexport function logToConsole(\n  type: \"info\" | \"error\",\n  source: UdfType,\n  udfPath: string,\n  message: string\n) {\n  const prefix = prefix_for_source(source);\n  if (type === \"info\") {\n    console.log(`%c[CONVEX ${prefix}(${udfPath})] ${message}`, INFO_COLOR);\n  } else {\n    console.error(`[CONVEX ${prefix}(${udfPath})] ${message}`);\n  }\n}\n\nexport function logFatalError(message: string): Error {\n  const errorMessage = `[CONVEX FATAL ERROR] ${message}`;\n  console.error(errorMessage);\n  return new Error(errorMessage);\n}\n\nexport function createError(\n  source: UdfType,\n  udfPath: string,\n  message: string\n): Error {\n  const prefix = prefix_for_source(source);\n  return new Error(`[CONVEX ${prefix}(${udfPath})] ${message}`);\n}\n", "import { convexToJson } from \"../../values/index.js\";\n\nexport function canonicalizeUdfPath(udfPath: string): string {\n  const pieces = udfPath.split(\":\");\n  let moduleName: string;\n  let functionName: string;\n  if (pieces.length === 1) {\n    moduleName = pieces[0];\n    functionName = \"default\";\n  } else {\n    moduleName = pieces.slice(0, pieces.length - 1).join(\":\");\n    functionName = pieces[pieces.length - 1];\n  }\n  if (!moduleName.endsWith(\".js\")) {\n    moduleName = `${moduleName}.js`;\n  }\n  return `${moduleName}:${functionName}`;\n}\n\n/**\n * A string representing the name and arguments of a query.\n *\n * This is used by the {@link InternalConvexClient}.\n *\n * @public\n */\nexport type QueryToken = string;\n\n// TODO(CX-749): Make this a unique representation (sort sets, dicts, objects)\nexport function serializePathAndArgs(udfPath: string, args: any[]): QueryToken {\n  return JSON.stringify({\n    udfPath: canonicalizeUdfPath(udfPath),\n    args: convexToJson(args),\n  });\n}\n", "import { convexToJson } from \"../../values/index.js\";\nimport {\n  AddQuery,\n  RemoveQuery,\n  QueryId,\n  QuerySetModification,\n  QuerySetVersion,\n  IdentityVersion,\n  Authenticate,\n  QueryJournal,\n  Transition,\n  AdminAuthentication,\n  UserIdentityAttributes,\n} from \"./protocol.js\";\nimport {\n  canonicalizeUdfPath,\n  QueryToken,\n  serializePathAndArgs,\n} from \"./udf_path_utils.js\";\n\ntype LocalQuery = {\n  id: QueryId;\n  canonicalizedUdfPath: string;\n  args: any[];\n  numSubscribers: number;\n  journal?: QueryJournal;\n};\n\nexport class LocalSyncState {\n  private nextQueryId: QueryId;\n  private querySetVersion: QuerySetVersion;\n  private readonly querySet: Map<QueryToken, LocalQuery>;\n  private readonly queryIdToToken: Map<QueryId, QueryToken>;\n  private identityVersion: IdentityVersion;\n  private auth?: {\n    tokenType: \"Admin\" | \"User\";\n    value: string;\n    impersonating?: UserIdentityAttributes;\n  };\n\n  constructor() {\n    this.nextQueryId = 0;\n    this.querySetVersion = 0;\n    this.identityVersion = 0;\n    this.querySet = new Map();\n    this.queryIdToToken = new Map();\n  }\n\n  subscribe(\n    udfPath: string,\n    args: any[],\n    journal?: QueryJournal\n  ): {\n    queryToken: QueryToken;\n    modification: QuerySetModification | null;\n    unsubscribe: () => QuerySetModification | null;\n  } {\n    const canonicalizedUdfPath = canonicalizeUdfPath(udfPath);\n    const queryToken = serializePathAndArgs(canonicalizedUdfPath, args);\n\n    const existingEntry = this.querySet.get(queryToken);\n\n    if (existingEntry !== undefined) {\n      existingEntry.numSubscribers += 1;\n      return {\n        queryToken,\n        modification: null,\n        unsubscribe: () => this.removeSubscriber(queryToken),\n      };\n    } else {\n      const queryId = this.nextQueryId++;\n      const query: LocalQuery = {\n        id: queryId,\n        canonicalizedUdfPath,\n        args,\n        numSubscribers: 1,\n        journal,\n      };\n      this.querySet.set(queryToken, query);\n      this.queryIdToToken.set(queryId, queryToken);\n\n      const baseVersion = this.querySetVersion;\n      const newVersion = ++this.querySetVersion;\n\n      const add: AddQuery = {\n        type: \"Add\",\n        queryId,\n        udfPath: canonicalizedUdfPath,\n        args: args.map(convexToJson),\n        journal,\n      };\n      const modification: QuerySetModification = {\n        type: \"ModifyQuerySet\",\n        baseVersion,\n        newVersion,\n        modifications: [add],\n      };\n      return {\n        queryToken,\n        modification,\n        unsubscribe: () => this.removeSubscriber(queryToken),\n      };\n    }\n  }\n\n  saveQueryJournals(transition: Transition) {\n    for (const modification of transition.modifications) {\n      switch (modification.type) {\n        case \"QueryUpdated\":\n        case \"QueryFailed\": {\n          const journal = modification.journal;\n          if (journal !== undefined) {\n            const queryToken = this.queryIdToToken.get(modification.queryId);\n            // We may have already unsubscribed to this query by the time the server\n            // sends us the journal. If so, just ignore it.\n            if (queryToken !== undefined) {\n              this.querySet.get(queryToken)!.journal = journal;\n            }\n          }\n\n          break;\n        }\n        case \"QueryRemoved\": {\n          break;\n        }\n        default: {\n          // Enforce that the switch-case is exhaustive.\n          const _: never = modification;\n          throw new Error(`Invalid modification ${modification}`);\n        }\n      }\n    }\n  }\n\n  queryId(udfPath: string, args: any[]): QueryId | null {\n    const canonicalizedUdfPath = canonicalizeUdfPath(udfPath);\n    const queryToken = serializePathAndArgs(canonicalizedUdfPath, args);\n    const existingEntry = this.querySet.get(queryToken);\n    if (existingEntry !== undefined) {\n      return existingEntry.id;\n    }\n    return null;\n  }\n\n  setAuth(value: string): Authenticate {\n    this.auth = {\n      tokenType: \"User\",\n      value: value,\n    };\n    const baseVersion = this.identityVersion++;\n    return {\n      type: \"Authenticate\",\n      baseVersion: baseVersion,\n      ...this.auth,\n    };\n  }\n\n  setAdminAuth(\n    value: string,\n    actingAs?: UserIdentityAttributes\n  ): AdminAuthentication {\n    const auth: typeof this.auth & {\n      tokenType: \"Admin\";\n    } = {\n      tokenType: \"Admin\",\n      value,\n      impersonating: actingAs,\n    };\n    this.auth = auth;\n    const baseVersion = this.identityVersion++;\n    return {\n      type: \"Authenticate\",\n      baseVersion: baseVersion,\n      ...auth,\n    };\n  }\n\n  clearAuth(): Authenticate {\n    this.auth = undefined;\n    const baseVersion = this.identityVersion++;\n    return {\n      type: \"Authenticate\",\n      tokenType: \"None\",\n      baseVersion: baseVersion,\n    };\n  }\n\n  hasAuth(): boolean {\n    return !!this.auth;\n  }\n\n  isNewAuth(value: string): boolean {\n    return this.auth?.value !== value;\n  }\n\n  queryPath(queryId: QueryId): string | null {\n    const pathAndArgs = this.queryIdToToken.get(queryId);\n    if (pathAndArgs) {\n      return this.querySet.get(pathAndArgs)!.canonicalizedUdfPath;\n    }\n    return null;\n  }\n\n  queryArgs(queryId: QueryId): any[] | null {\n    const pathAndArgs = this.queryIdToToken.get(queryId);\n    if (pathAndArgs) {\n      return this.querySet.get(pathAndArgs)!.args;\n    }\n    return null;\n  }\n\n  queryToken(queryId: QueryId): string | null {\n    return this.queryIdToToken.get(queryId) ?? null;\n  }\n\n  queryJournal(queryToken: QueryToken): QueryJournal | undefined {\n    return this.querySet.get(queryToken)?.journal;\n  }\n\n  restart(): [QuerySetModification, Authenticate?] {\n    const modifications = [];\n    for (const localQuery of this.querySet.values()) {\n      const add: AddQuery = {\n        type: \"Add\",\n        queryId: localQuery.id,\n        udfPath: localQuery.canonicalizedUdfPath,\n        args: localQuery.args.map(convexToJson),\n        journal: localQuery.journal,\n      };\n      modifications.push(add);\n    }\n    this.querySetVersion = 1;\n    const querySet: QuerySetModification = {\n      type: \"ModifyQuerySet\",\n      baseVersion: 0,\n      newVersion: 1,\n      modifications,\n    };\n    // If there's no auth, no need to send an update as the server will also start with an unknown identity.\n    if (!this.auth) {\n      this.identityVersion = 0;\n      return [querySet, undefined];\n    }\n    const authenticate: Authenticate = {\n      type: \"Authenticate\",\n      baseVersion: 0,\n      ...this.auth,\n    };\n    this.identityVersion = 1;\n    return [querySet, authenticate];\n  }\n\n  private removeSubscriber(\n    queryToken: QueryToken\n  ): QuerySetModification | null {\n    const localQuery = this.querySet.get(queryToken)!;\n\n    if (localQuery.numSubscribers > 1) {\n      localQuery.numSubscribers -= 1;\n      return null;\n    } else {\n      this.querySet.delete(queryToken);\n      this.queryIdToToken.delete(localQuery.id);\n      const baseVersion = this.querySetVersion;\n      const newVersion = ++this.querySetVersion;\n      const remove: RemoveQuery = {\n        type: \"Remove\",\n        queryId: localQuery.id,\n      };\n      return {\n        type: \"ModifyQuerySet\",\n        baseVersion,\n        newVersion,\n        modifications: [remove],\n      };\n    }\n  }\n}\n", "import { jsonToConvex } from \"../../values/index.js\";\nimport { createError, logToConsole } from \"../logging.js\";\nimport { Long } from \"../long.js\";\nimport {\n  ActionRequest,\n  ActionResponse,\n  ClientMessage,\n  MutationRequest,\n  MutationResponse,\n  RequestId,\n} from \"./protocol.js\";\n\ntype RequestStatus =\n  | {\n      status: \"Requested\" | \"NotSent\";\n      onResult: (result: any) => void;\n      onFailure: (reason: any) => void;\n    }\n  | {\n      status: \"Completed\";\n      onResolve: () => void;\n      ts: Long;\n    };\n\nexport class RequestManager {\n  private inflightRequests: Map<\n    RequestId,\n    {\n      message: MutationRequest | ActionRequest;\n      status: RequestStatus;\n    }\n  >;\n  constructor() {\n    this.inflightRequests = new Map();\n  }\n\n  request(\n    message: MutationRequest | ActionRequest,\n    sent: boolean\n  ): Promise<any> {\n    const result = new Promise((resolve, reject) => {\n      const status = sent ? \"Requested\" : \"NotSent\";\n      this.inflightRequests.set(message.requestId, {\n        message,\n        status: { status, onResult: resolve, onFailure: reject },\n      });\n    });\n\n    return result;\n  }\n\n  /**\n   * Update the state after receiving a response.\n   *\n   * @returns A RequestId if the request is complete and its optimistic update\n   * can be dropped, null otherwise.\n   */\n  onResponse(response: MutationResponse | ActionResponse): RequestId | null {\n    const requestInfo = this.inflightRequests.get(response.requestId);\n    if (requestInfo === undefined) {\n      // Annoyingly we can occasionally get responses to mutations that we're no\n      // longer tracking. One flow where this happens is:\n      // 1. Client sends mutation 1\n      // 2. Client gets response for mutation 1. The sever says that it was committed at ts=10.\n      // 3. Client is disconnected\n      // 4. Client reconnects and re-issues queries and this mutation.\n      // 5. Server sends transition message to ts=20\n      // 6. Client drops mutation because it's already been observed.\n      // 7. Client receives a second response for mutation 1 but doesn't know about it anymore.\n\n      // The right fix for this is probably to add a reconciliation phase on\n      // reconnection where we receive responses to all the mutations before\n      // the transition message so this flow could never happen (CX-1513).\n\n      // For now though, we can just ignore this message.\n      return null;\n    }\n\n    // Because `.restart()` re-requests completed requests, we may get some\n    // responses for requests that are already in the \"Completed\" state.\n    // We can safely ignore those because we've already notified the UI about\n    // their results.\n    if (requestInfo.status.status === \"Completed\") {\n      return null;\n    }\n\n    const udfType =\n      requestInfo.message.type === \"Mutation\" ? \"mutation\" : \"action\";\n    const udfPath = requestInfo.message.udfPath;\n\n    for (const line of response.logLines) {\n      logToConsole(\"info\", udfType, udfPath, line);\n    }\n\n    const status = requestInfo.status;\n    let onResolve;\n    if (response.success) {\n      onResolve = () => status.onResult(jsonToConvex(response.result));\n    } else {\n      logToConsole(\"error\", udfType, udfPath, response.result);\n      onResolve = () =>\n        status.onFailure(createError(udfType, udfPath, response.result));\n    }\n\n    // We can resolve Mutation failures immediately since they don't have any\n    // side effects.\n    // TODO(presley): Add timestamp to ActionResponse so the client can read\n    // its own writes on the happy path.\n    if (response.type === \"ActionResponse\" || !response.success) {\n      onResolve();\n      this.inflightRequests.delete(response.requestId);\n      return response.requestId;\n    }\n\n    // We have to wait to resolve the request promise until after we transition\n    // past this timestamp so clients can read their own writes.\n    requestInfo.status = {\n      status: \"Completed\",\n      ts: response.ts,\n      onResolve,\n    };\n\n    return null;\n  }\n\n  // Remove and returns completed requests.\n  removeCompleted(ts: Long): Set<RequestId> {\n    const completeRequests: Set<RequestId> = new Set();\n    for (const [requestId, requestInfo] of this.inflightRequests.entries()) {\n      const status = requestInfo.status;\n      if (status.status === \"Completed\" && status.ts.lessThanOrEqual(ts)) {\n        status.onResolve();\n        completeRequests.add(requestId);\n        this.inflightRequests.delete(requestId);\n      }\n    }\n    return completeRequests;\n  }\n\n  restart(): ClientMessage[] {\n    // When we reconnect to the backend, re-request all requests that are safe\n    // to be resend.\n\n    const allMessages = [];\n    for (const [requestId, value] of this.inflightRequests) {\n      if (value.status.status === \"NotSent\") {\n        value.status.status = \"Requested\";\n        allMessages.push(value.message);\n        continue;\n      }\n\n      if (value.message.type === \"Mutation\") {\n        // This includes ones that have already been completed because we still\n        // want to tell the backend to transition the client past the completed\n        // timestamp. This is safe since mutations are idempotent.\n        allMessages.push(value.message);\n      } else {\n        // Unlike mutations, actions are not idempotent. When we reconnect to the\n        // backend, we don't know if it is safe to resend in-flight actions, so we\n        // cancel them and consider them failed.\n        this.inflightRequests.delete(requestId);\n        const udfPath = value.message.udfPath;\n        if (value.status.status === \"Completed\") {\n          throw new Error(\"Action should never be in 'Completed' state\");\n        }\n        value.status.onFailure(\n          createError(\"action\", udfPath, \"Transient error\")\n        );\n      }\n    }\n    return allMessages;\n  }\n\n  /**\n   ** @returns true if there are any requests that have been requested but have\n   ** not be completed yet.\n   **/\n  hasIncompleteRequests(): boolean {\n    for (const requestInfo of this.inflightRequests.values()) {\n      if (requestInfo.status.status === \"Requested\") {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   ** @returns true if there are any inflight requests, including ones that have\n   ** completed on the server, but have not been applied.\n   **/\n  hasInflightRequests(): boolean {\n    return this.inflightRequests.size > 0;\n  }\n}\n", "import { Value } from \"../../values/index.js\";\nimport { createError } from \"../logging.js\";\nimport { OptimisticLocalStore } from \"./optimistic_updates.js\";\nimport { RequestId } from \"./protocol.js\";\nimport { QueryResult } from \"./remote_query_set.js\";\nimport {\n  canonicalizeUdfPath,\n  QueryToken,\n  serializePathAndArgs,\n} from \"./udf_path_utils.js\";\n\n/**\n * An optimistic update function that has been curried over its arguments.\n */\ntype WrappedOptimisticUpdate = (locaQueryStore: OptimisticLocalStore) => void;\n\n/**\n * The implementation of `OptimisticLocalStore`.\n *\n * This class provides the interface for optimistic updates to modify query results.\n */\nclass OptimisticLocalStoreImpl implements OptimisticLocalStore {\n  // A references of the query results in OptimisticQueryResults\n  private readonly queryResults: QueryResultsMap;\n\n  // All of the queries modified by this class\n  readonly modifiedQueries: QueryToken[];\n\n  constructor(queryResults: QueryResultsMap) {\n    this.queryResults = queryResults;\n    this.modifiedQueries = [];\n  }\n\n  getQuery(name: string, args: Value[]): Value | undefined {\n    const query = this.queryResults.get(serializePathAndArgs(name, args));\n    if (query === undefined) {\n      return undefined;\n    }\n    return OptimisticLocalStoreImpl.queryValue(query.result);\n  }\n\n  getAllQueries(name: string): { args: Value[]; value: Value | undefined }[] {\n    const queriesWithName = [];\n    for (const query of this.queryResults.values()) {\n      if (query.udfPath === canonicalizeUdfPath(name)) {\n        queriesWithName.push({\n          args: query.args,\n          value: OptimisticLocalStoreImpl.queryValue(query.result),\n        });\n      }\n    }\n    return queriesWithName;\n  }\n\n  setQuery(name: string, args: Value[], value: Value | undefined): void {\n    const queryToken = serializePathAndArgs(name, args);\n\n    let result: QueryResult | undefined;\n    if (value === undefined) {\n      result = undefined;\n    } else {\n      result = {\n        success: true,\n        value,\n      };\n    }\n    const query: Query = {\n      udfPath: name,\n      args,\n      result,\n    };\n    this.queryResults.set(queryToken, query);\n    this.modifiedQueries.push(queryToken);\n  }\n\n  private static queryValue(\n    result: QueryResult | undefined\n  ): Value | undefined {\n    if (result === undefined) {\n      return undefined;\n    } else if (result.success) {\n      return result.value;\n    } else {\n      // If the query is an error state, just return `undefined` as though\n      // it's loading. Optimistic updates should already handle `undefined` well\n      // and there isn't a need to break the whole update because it tried\n      // to load a single query that errored.\n      return undefined;\n    }\n  }\n}\n\ntype OptimisticUpdateAndId = {\n  update: WrappedOptimisticUpdate;\n  mutationId: RequestId;\n};\n\ntype Query = {\n  // undefined means the query was set to be loading (undefined) in an optimistic update.\n  // Note that we can also have queries not present in the QueryResultMap\n  // at all because they are still loading from the server.\n  result: QueryResult | undefined;\n  udfPath: string;\n  args: Value[];\n};\nexport type QueryResultsMap = Map<QueryToken, Query>;\n\ntype ChangedQueries = QueryToken[];\n\n/**\n * A view of all of our query results with optimistic updates applied on top.\n */\nexport class OptimisticQueryResults {\n  private queryResults: QueryResultsMap;\n  private optimisticUpdates: OptimisticUpdateAndId[];\n\n  constructor() {\n    this.queryResults = new Map();\n    this.optimisticUpdates = [];\n  }\n\n  ingestQueryResultsFromServer(\n    serverQueryResults: QueryResultsMap,\n    optimisticUpdatesToDrop: Set<RequestId>\n  ): ChangedQueries {\n    this.optimisticUpdates = this.optimisticUpdates.filter(updateAndId => {\n      return !optimisticUpdatesToDrop.has(updateAndId.mutationId);\n    });\n\n    const oldQueryResults = this.queryResults;\n    this.queryResults = new Map(serverQueryResults);\n    const localStore = new OptimisticLocalStoreImpl(this.queryResults);\n    for (const updateAndId of this.optimisticUpdates) {\n      updateAndId.update(localStore);\n    }\n\n    // To find the changed queries, just do a shallow comparison\n    // TODO(CX-733): Change this so we avoid unnecessary rerenders\n    const changedQueries: ChangedQueries = [];\n    for (const [queryToken, query] of this.queryResults) {\n      const oldQuery = oldQueryResults.get(queryToken);\n      if (oldQuery === undefined || oldQuery.result !== query.result) {\n        changedQueries.push(queryToken);\n      }\n    }\n\n    return changedQueries;\n  }\n\n  applyOptimisticUpdate(\n    update: WrappedOptimisticUpdate,\n    mutationId: RequestId\n  ): ChangedQueries {\n    // Apply the update to our store\n    this.optimisticUpdates.push({\n      update,\n      mutationId,\n    });\n    const localStore = new OptimisticLocalStoreImpl(this.queryResults);\n    update(localStore);\n\n    // Notify about any query results that changed\n    // TODO(CX-733): Change this so we avoid unnecessary rerenders\n    return localStore.modifiedQueries;\n  }\n\n  queryResult(queryToken: QueryToken): Value | undefined {\n    const query = this.queryResults.get(queryToken);\n    if (query === undefined) {\n      return undefined;\n    }\n    const result = query.result;\n    if (result === undefined) {\n      return undefined;\n    } else if (result.success) {\n      return result.value;\n    } else {\n      throw createError(\"query\", query.udfPath, result.errorMessage);\n    }\n  }\n}\n", "// Implements an unsigned long.\n// This is a subset of https://github.com/dcodeIO/Long.js\n// `| 0` assures the runtime that we are using integer arithmetic\n\n// This works... but don't try to compare one to a real Long.js Long!\n// For internal use only.\nexport class Long {\n  low: number;\n  high: number;\n  __isUnsignedLong__: boolean;\n\n  static isLong(obj: Long) {\n    return (obj && obj.__isUnsignedLong__) === true;\n  }\n\n  constructor(low: number, high: number) {\n    this.low = low | 0;\n    this.high = high | 0;\n    this.__isUnsignedLong__ = true;\n  }\n\n  // prettier-ignore\n  static fromBytesLE(bytes: number[]): Long {\n    return new Long(\n      bytes[0] |\n      bytes[1] << 8 |\n      bytes[2] << 16 |\n      bytes[3] << 24,\n      bytes[4] |\n      bytes[5] << 8 |\n      bytes[6] << 16 |\n      bytes[7] << 24,\n    );\n  }\n\n  // prettier-ignore\n  toBytesLE() {\n    const hi = this.high;\n    const lo = this.low;\n    return [\n      lo & 0xff,\n      lo >>> 8 & 0xff,\n      lo >>> 16 & 0xff,\n      lo >>> 24,\n      hi & 0xff,\n      hi >>> 8 & 0xff,\n      hi >>> 16 & 0xff,\n      hi >>> 24\n    ];\n  }\n\n  static fromNumber(value: number) {\n    if (isNaN(value)) return UZERO;\n    if (value < 0) return UZERO;\n    if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;\n    return new Long(value % TWO_PWR_32_DBL | 0, (value / TWO_PWR_32_DBL) | 0);\n  }\n\n  equals(other: Long) {\n    if (!Long.isLong(other)) other = Long.fromValue(other);\n    if (this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;\n    return this.high === other.high && this.low === other.low;\n  }\n\n  notEquals(other: Long) {\n    return !this.equals(other);\n  }\n\n  comp(other: Long) {\n    if (!Long.isLong(other)) other = Long.fromValue(other);\n    if (this.equals(other)) return 0;\n    return other.high >>> 0 > this.high >>> 0 ||\n      (other.high === this.high && other.low >>> 0 > this.low >>> 0)\n      ? -1\n      : 1;\n  }\n\n  lessThanOrEqual(other: Long) {\n    return this.comp(/* validates */ other) <= 0;\n  }\n\n  static fromValue(val: any) {\n    if (typeof val === \"number\") return Long.fromNumber(val);\n    // Throws for non-objects, converts non-instanceof Long:\n    return new Long(val.low, val.high);\n  }\n}\n\nconst UZERO = new Long(0, 0);\nconst TWO_PWR_16_DBL = 1 << 16;\nconst TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nconst TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\nconst MAX_UNSIGNED_VALUE = new Long(0xffffffff | 0, 0xffffffff | 0);\n", "import { jsonToConvex, Value } from \"../../values/index.js\";\nimport { Long } from \"../long.js\";\nimport { logToConsole } from \"../logging.js\";\nimport { QueryId, StateVersion, Transition } from \"./protocol.js\";\n\n/**\n * The result of running a query function on the server.\n *\n * If the function hit an exception it will have an `errorMessage`. Otherwise\n * it will produce a `Value`.\n *\n * @public\n */\nexport type QueryResult =\n  | {\n      success: true;\n      value: Value;\n    }\n  | { success: false; errorMessage: string };\n\n/**\n * A represention of the query results we've received on the current WebSocket\n * connection.\n */\nexport class RemoteQuerySet {\n  private version: StateVersion;\n  private readonly remoteQuerySet: Map<QueryId, QueryResult>;\n  private readonly queryPath: (queryId: QueryId) => string | null;\n\n  constructor(queryPath: (queryId: QueryId) => string | null) {\n    this.version = { querySet: 0, ts: Long.fromNumber(0), identity: 0 };\n    this.remoteQuerySet = new Map();\n    this.queryPath = queryPath;\n  }\n\n  transition(transition: Transition): void {\n    const start = transition.startVersion;\n    if (\n      this.version.querySet !== start.querySet ||\n      this.version.ts.notEquals(start.ts) ||\n      this.version.identity !== start.identity\n    ) {\n      throw new Error(`Invalid start version: ${start.ts}:${start.querySet}`);\n    }\n    for (const modification of transition.modifications) {\n      switch (modification.type) {\n        case \"QueryUpdated\": {\n          const queryPath = this.queryPath(modification.queryId);\n          if (queryPath) {\n            for (const line of modification.logLines) {\n              logToConsole(\"info\", \"query\", queryPath, line);\n            }\n          }\n          const value = jsonToConvex(modification.value ?? null);\n          this.remoteQuerySet.set(modification.queryId, {\n            success: true,\n            value,\n          });\n          break;\n        }\n        case \"QueryFailed\": {\n          const queryPath = this.queryPath(modification.queryId);\n          if (queryPath) {\n            for (const line of modification.logLines) {\n              logToConsole(\"info\", \"query\", queryPath, line);\n            }\n          }\n\n          this.remoteQuerySet.set(modification.queryId, {\n            success: false,\n            errorMessage: modification.errorMessage,\n          });\n          break;\n        }\n        case \"QueryRemoved\": {\n          this.remoteQuerySet.delete(modification.queryId);\n          break;\n        }\n        default: {\n          // Enforce that the switch-case is exhaustive.\n          const _: never = modification;\n          throw new Error(`Invalid modification ${modification}`);\n        }\n      }\n    }\n    this.version = transition.endVersion;\n  }\n\n  remoteQueryResults(): Map<QueryId, QueryResult> {\n    return this.remoteQuerySet;\n  }\n\n  timestamp(): Long {\n    return this.version.ts;\n  }\n}\n", "import * as Base64 from \"base64-js\";\nimport { UserIdentity } from \"../../server/authentication.js\";\nimport { JSONValue } from \"../../values/index.js\";\nimport { Long } from \"../long.js\";\n\n/**\n * Shared schema\n */\n\nexport function u64ToLong(encoded: EncodedU64): U64 {\n  const integerBytes = Base64.toByteArray(encoded);\n  return Long.fromBytesLE(Array.from(integerBytes));\n}\n\nexport function parseServerMessage(\n  encoded: EncodedServerMessage\n): ServerMessage {\n  switch (encoded.type) {\n    case \"FatalError\":\n    case \"AuthError\":\n    case \"ActionResponse\":\n    case \"Ping\": {\n      return { ...encoded };\n    }\n    case \"MutationResponse\": {\n      if (encoded.success) {\n        return { ...encoded, ts: u64ToLong(encoded.ts) };\n      } else {\n        return { ...encoded };\n      }\n    }\n    case \"Transition\": {\n      return {\n        ...encoded,\n        startVersion: {\n          ...encoded.startVersion,\n          ts: u64ToLong(encoded.startVersion.ts),\n        },\n        endVersion: {\n          ...encoded.endVersion,\n          ts: u64ToLong(encoded.endVersion.ts),\n        },\n      };\n    }\n    default: {\n      const _exhaustivenessCheck: never = encoded;\n    }\n  }\n  return undefined as never;\n}\n\ntype U64 = Long;\ntype EncodedU64 = string;\n\n/**\n * Unique nonnegative integer identifying a single query.\n */\nexport type QueryId = number; // nonnegative int\n\nexport type QuerySetVersion = number; // nonnegative int\n\nexport type RequestId = number; // nonnegative int\n\nexport type IdentityVersion = number; // nonnegative int\n\n/**\n * A serialized representation of decisions made during a query's execution.\n *\n * A journal is produced when a query function first executes and is re-used\n * when a query is re-executed.\n *\n * Currently this is used to store pagination end cursors to ensure\n * that pages of paginated queries will always end at the same cursor. This\n * enables gapless, reactive pagination.\n *\n * `null` is used to represent empty journals.\n * @public\n */\nexport type QueryJournal = string | null;\n\n/**\n * Client message schema\n */\n\ntype Connect = {\n  type: \"Connect\";\n  sessionId: string;\n  connectionCount: number;\n  lastCloseReason: string | null;\n};\n\nexport type AddQuery = {\n  type: \"Add\";\n  queryId: QueryId;\n  udfPath: string;\n  args: JSONValue[];\n  journal?: QueryJournal;\n};\n\nexport type RemoveQuery = {\n  type: \"Remove\";\n  queryId: QueryId;\n};\n\nexport type QuerySetModification = {\n  type: \"ModifyQuerySet\";\n  baseVersion: QuerySetVersion;\n  newVersion: QuerySetVersion;\n  modifications: (AddQuery | RemoveQuery)[];\n};\n\nexport type MutationRequest = {\n  type: \"Mutation\";\n  requestId: RequestId;\n  udfPath: string;\n  args: JSONValue[];\n};\n\nexport type ActionRequest = {\n  type: \"Action\";\n  requestId: RequestId;\n  udfPath: string;\n  args: JSONValue[];\n};\n\n/** @internal */\nexport type UserIdentityAttributes = Omit<\n  UserIdentity,\n  // Issuer is not necessary, updatedAt expects a string and not a date.\n  \"updatedAt\" | \"issuer\"\n> & {\n  updatedAt?: string;\n};\n\nexport type AdminAuthentication = {\n  type: \"Authenticate\";\n  tokenType: \"Admin\";\n  value: string;\n  baseVersion: IdentityVersion;\n  impersonating?: UserIdentityAttributes;\n};\n\nexport type Authenticate =\n  | AdminAuthentication\n  | {\n      type: \"Authenticate\";\n      tokenType: \"User\";\n      value: string;\n      baseVersion: IdentityVersion;\n    }\n  | {\n      type: \"Authenticate\";\n      tokenType: \"None\";\n      baseVersion: IdentityVersion;\n    };\nexport type ClientMessage =\n  | Connect\n  | Authenticate\n  | QuerySetModification\n  | MutationRequest\n  | ActionRequest;\n\n/**\n * Server message schema\n */\ntype TS = U64;\ntype EncodedTS = EncodedU64;\ntype LogLines = string[];\n\nexport type StateVersion = {\n  querySet: QueryId;\n  ts: TS;\n  identity: IdentityVersion;\n};\ntype EncodedStateVersion = Omit<StateVersion, \"ts\"> & { ts: EncodedTS };\n\ntype StateModification =\n  | {\n      type: \"QueryUpdated\";\n      queryId: QueryId;\n      value: JSONValue;\n      logLines: LogLines;\n      // Optional because old backend versions don't send this.\n      journal?: QueryJournal;\n    }\n  | {\n      type: \"QueryFailed\";\n      queryId: QueryId;\n      errorMessage: string;\n      logLines: LogLines;\n      // Optional because old backend versions don't send this.\n      journal?: QueryJournal;\n    }\n  | {\n      type: \"QueryRemoved\";\n      queryId: QueryId;\n    };\n\nexport type Transition = {\n  type: \"Transition\";\n  startVersion: StateVersion;\n  endVersion: StateVersion;\n  modifications: StateModification[];\n};\n\ntype MutationSuccess = {\n  type: \"MutationResponse\";\n  requestId: RequestId;\n  success: true;\n  result: JSONValue;\n  ts: TS;\n  logLines: LogLines;\n};\ntype MutationFailed = {\n  type: \"MutationResponse\";\n  requestId: RequestId;\n  success: false;\n  result: string;\n  logLines: LogLines;\n};\nexport type MutationResponse = MutationSuccess | MutationFailed;\ntype ActionSuccess = {\n  type: \"ActionResponse\";\n  requestId: RequestId;\n  success: true;\n  result: JSONValue;\n  logLines: LogLines;\n};\ntype ActionFailed = {\n  type: \"ActionResponse\";\n  requestId: RequestId;\n  success: false;\n  result: string;\n  logLines: LogLines;\n};\nexport type ActionResponse = ActionSuccess | ActionFailed;\nexport type AuthError = {\n  type: \"AuthError\";\n  error: string;\n};\ntype FatalError = {\n  type: \"FatalError\";\n  error: string;\n};\ntype Ping = {\n  type: \"Ping\";\n};\n\nexport type ServerMessage =\n  | Transition\n  | MutationResponse\n  | ActionResponse\n  | FatalError\n  | AuthError\n  | Ping;\n\ntype EncodedTransition = Omit<Transition, \"startVersion\" | \"endVersion\"> & {\n  startVersion: EncodedStateVersion;\n  endVersion: EncodedStateVersion;\n};\ntype EncodedMutationSuccess = Omit<MutationSuccess, \"ts\"> & { ts: EncodedTS };\ntype EncodedMutationResponse = MutationFailed | EncodedMutationSuccess;\n\ntype EncodedServerMessage =\n  | EncodedTransition\n  | EncodedMutationResponse\n  | ActionResponse\n  | FatalError\n  | AuthError\n  | Ping;\n", "import {\n  ClientMessage,\n  parseServerMessage,\n  ServerMessage,\n} from \"./protocol.js\";\n\nconst CLOSE_NORMAL = 1000;\nconst CLOSE_GOING_AWAY = 1001;\nconst CLOSE_NO_STATUS = 1005;\n/** Convex-specific close code representing a \"404 Not Found\".\n * The edge Onramp accepts websocket upgrades before confirming that the\n * intended destination exists, so this code is sent once we've discovered that\n * the destination does not exist.\n */\nconst CLOSE_NOT_FOUND = 4040;\n\ntype PromisePair<T> = { promise: Promise<T>; resolve: (value: T) => void };\n\n/**\n * The various states our WebSocket can be in:\n *\n * - \"disconnected\": We don't have a WebSocket, but plan to create one.\n * - \"connecting\": We have created the WebSocket and are waiting for the\n *   `onOpen` callback.\n * - \"ready\": We have an open WebSocket.\n * - \"closing\": We called `.close()` on the WebSocket and are waiting for the\n *   `onClose` callback before we schedule a reconnect.\n * - \"stopping\": The application decided to totally stop the WebSocket. We are\n *    waiting for the `onClose` callback before we consider this WebSocket stopped.\n * - \"pausing\": The client needs to fetch some data before it makes sense to resume\n *    the WebSocket connection.\n * - \"paused\": The WebSocket was stopped and a new one can be created via `.resume()`.\n * - \"stopped\": We have stopped the WebSocket and will never create a new one.\n *\n *\n * WebSocket State Machine\n * -----------------------\n * initialState: disconnected\n * validTransitions:\n *   disconnected:\n *     new WebSocket() -> connecting\n *     stop() -> stopped\n *   connecting:\n *     onopen -> ready\n *     close() -> closing\n *     stop() -> stopping\n *   ready:\n *     close() -> closing\n *     pause() -> pausing\n *     stop() -> stopping\n *   closing:\n *     onclose -> disconnected\n *     stop() -> stopping\n *   pausing:\n *     onclose -> paused\n *     stop() -> stopping\n *   paused:\n *     resume() -> connecting\n *     stop() -> stopped\n *   stopping:\n *     onclose -> stopped\n * terminalStates:\n *   stopped\n */\ntype Socket =\n  | { state: \"disconnected\" }\n  | { state: \"connecting\"; ws: WebSocket }\n  | { state: \"ready\"; ws: WebSocket }\n  | { state: \"closing\"; ws: WebSocket }\n  | { state: \"pausing\"; promisePair: PromisePair<null> }\n  | { state: \"paused\" }\n  | { state: \"stopping\"; promisePair: PromisePair<null> }\n  | { state: \"stopped\" };\n\nfunction promisePair<T>(): PromisePair<T> {\n  let resolvePromise: (value: T) => void;\n  const promise = new Promise<T>(resolve => {\n    resolvePromise = resolve;\n  });\n  return { promise, resolve: resolvePromise! };\n}\n\nexport type ReconnectMetadata = {\n  connectionCount: number;\n  lastCloseReason: string | null;\n};\n\n/**\n * A wrapper around a websocket that handles errors, reconnection, and message\n * parsing.\n */\nexport class WebSocketManager {\n  private socket: Socket;\n\n  private connectionCount: number;\n  private lastCloseReason: string | null;\n\n  /** Upon HTTPS/WSS failure, the first jittered backoff duration, in ms. */\n  private readonly initialBackoff: number;\n\n  /** We backoff exponentially, but we need to cap that--this is the jittered max. */\n  private readonly maxBackoff: number;\n\n  /** How many times have we failed consecutively? */\n  private retries: number;\n\n  /** How long before lack of server response causes us to initiate a reconnect,\n   * in ms */\n  private readonly serverInactivityThreshold: number;\n\n  private reconnectDueToServerInactivityTimeout: ReturnType<\n    typeof setTimeout\n  > | null;\n\n  private readonly uri: string;\n  private readonly onOpen: (reconnectMetadata: ReconnectMetadata) => void;\n  private readonly onMessage: (message: ServerMessage) => void;\n  private readonly webSocketConstructor: typeof WebSocket;\n  private readonly verbose: boolean;\n\n  constructor(\n    uri: string,\n    onOpen: (reconnectMetadata: ReconnectMetadata) => void,\n    onMessage: (message: ServerMessage) => void,\n    webSocketConstructor: typeof WebSocket,\n    verbose: boolean\n  ) {\n    this.webSocketConstructor = webSocketConstructor;\n    this.socket = { state: \"disconnected\" };\n    this.connectionCount = 0;\n    this.lastCloseReason = \"InitialConnect\";\n\n    this.initialBackoff = 100;\n    this.maxBackoff = 16000;\n    this.retries = 0;\n\n    this.serverInactivityThreshold = 30000;\n    this.reconnectDueToServerInactivityTimeout = null;\n\n    this.uri = uri;\n    this.onOpen = onOpen;\n    this.onMessage = onMessage;\n    this.verbose = verbose;\n\n    // Kick off connection but don't wait for it.\n    void this.connect();\n  }\n\n  private async connect() {\n    if (\n      this.socket.state === \"closing\" ||\n      this.socket.state === \"stopping\" ||\n      this.socket.state === \"stopped\"\n    ) {\n      return;\n    }\n    if (\n      this.socket.state !== \"disconnected\" &&\n      this.socket.state !== \"paused\"\n    ) {\n      throw new Error(\"Didn't start connection from disconnected state\");\n    }\n\n    const ws = new this.webSocketConstructor(this.uri);\n    this._logVerbose(\"constructed WebSocket\");\n    this.socket = {\n      state: \"connecting\",\n      ws,\n    };\n    ws.onopen = () => {\n      this._logVerbose(\"begin ws.onopen\");\n      if (this.socket.state !== \"connecting\") {\n        throw new Error(\"onopen called with socket not in connecting state\");\n      }\n      this.socket = { state: \"ready\", ws };\n      this.onServerActivity();\n      this.onOpen({\n        connectionCount: this.connectionCount,\n        lastCloseReason: this.lastCloseReason,\n      });\n\n      if (this.lastCloseReason !== \"InitialConnect\") {\n        console.log(\"WebSocket reconnected\");\n      }\n\n      this.connectionCount += 1;\n      this.lastCloseReason = null;\n    };\n    // NB: The WebSocket API calls `onclose` even if connection fails, so we can route all error paths through `onclose`.\n    ws.onerror = error => {\n      const message = (error as ErrorEvent).message;\n      console.log(`WebSocket error: ${message}`);\n      this.closeAndReconnect(\"WebSocketError\");\n    };\n    ws.onmessage = message => {\n      // TODO(CX-1498): We reset the retry counter on any successful message.\n      // This is not ideal and we should improve this further.\n      this.retries = 0;\n      this.onServerActivity();\n      const serverMessage = parseServerMessage(JSON.parse(message.data));\n      this._logVerbose(`received ws message with type ${serverMessage.type}`);\n      this.onMessage(serverMessage);\n    };\n    ws.onclose = event => {\n      if (this.lastCloseReason === null) {\n        this.lastCloseReason = event.reason ?? \"OnCloseInvoked\";\n      }\n      if (\n        event.code !== CLOSE_NORMAL &&\n        event.code !== CLOSE_GOING_AWAY && // This commonly gets fired on mobile apps when the app is backgrounded\n        event.code !== CLOSE_NO_STATUS &&\n        event.code !== CLOSE_NOT_FOUND // Note that we want to retry on a 404, as it can be transient during a push.\n      ) {\n        let msg = `WebSocket closed unexpectedly with code ${event.code}`;\n        if (event.reason) {\n          msg += `: ${event.reason}`;\n        }\n        console.error(msg);\n      }\n      if (this.socket.state === \"stopping\") {\n        this.socket.promisePair.resolve(null);\n        this.socket = { state: \"stopped\" };\n        return;\n      }\n      if (this.socket.state === \"pausing\") {\n        this.socket.promisePair.resolve(null);\n        this.socket = { state: \"paused\" };\n        return;\n      }\n      this.socket = { state: \"disconnected\" };\n      const backoff = this.nextBackoff();\n      console.log(`Attempting reconnect in ${backoff}ms`);\n      setTimeout(() => this.connect(), backoff);\n    };\n  }\n\n  /**\n   * @returns The state of the {@link Socket}.\n   */\n  socketState(): string {\n    return this.socket.state;\n  }\n\n  /**\n   * @param message - A ClientMessage to send.\n   * @returns Whether the message (might have been) sent.\n   */\n  sendMessage(message: ClientMessage) {\n    this._logVerbose(`sending message with type ${message.type}`);\n    if (this.socket.state === \"ready\") {\n      const request = JSON.stringify(message);\n      try {\n        this.socket.ws.send(request);\n      } catch (error: any) {\n        console.log(\n          `Failed to send message on WebSocket, reconnecting: ${error}`\n        );\n        this.closeAndReconnect(\"FailedToSendMessage\");\n      }\n      // We are not sure if this was sent or not.\n      return true;\n    }\n    return false;\n  }\n\n  private onServerActivity() {\n    if (this.reconnectDueToServerInactivityTimeout !== null) {\n      clearTimeout(this.reconnectDueToServerInactivityTimeout);\n      this.reconnectDueToServerInactivityTimeout = null;\n    }\n    this.reconnectDueToServerInactivityTimeout = setTimeout(() => {\n      this.closeAndReconnect(\"InactiveServer\");\n    }, this.serverInactivityThreshold);\n  }\n\n  /**\n   * Close the WebSocket and schedule a reconnect when it completes closing.\n   *\n   * This should be used when we hit an error and would like to restart the session.\n   */\n  private closeAndReconnect(closeReason: string) {\n    switch (this.socket.state) {\n      case \"disconnected\":\n      case \"closing\":\n      case \"stopping\":\n      case \"stopped\":\n      case \"pausing\":\n      case \"paused\":\n        // Nothing to do if we don't have a WebSocket.\n        return;\n      case \"connecting\":\n      case \"ready\":\n        this.lastCloseReason = closeReason;\n        this.socket.ws.close();\n        this.socket = {\n          state: \"closing\",\n          ws: this.socket.ws,\n        };\n        return;\n      default: {\n        // Enforce that the switch-case is exhaustive.\n        // eslint-disable-next-line  @typescript-eslint/no-unused-vars\n        const _: never = this.socket;\n      }\n    }\n  }\n\n  /**\n   * Close the WebSocket and do not reconnect.\n   * @returns A Promise that resolves when the WebSocket `onClose` callback is called.\n   */\n  async stop(): Promise<void> {\n    if (this.reconnectDueToServerInactivityTimeout) {\n      clearTimeout(this.reconnectDueToServerInactivityTimeout);\n    }\n    switch (this.socket.state) {\n      case \"stopped\":\n        return;\n      case \"connecting\":\n      case \"ready\":\n        this.socket.ws.close();\n        this.socket = {\n          state: \"stopping\",\n          promisePair: promisePair(),\n        };\n        await this.socket.promisePair.promise;\n        return;\n      case \"pausing\":\n      case \"closing\":\n        // We're already closing the WebSocket, so just upgrade the state\n        // to \"stopping\" so we don't reconnect.\n        this.socket = {\n          state: \"stopping\",\n          promisePair: promisePair(),\n        };\n        await this.socket.promisePair.promise;\n        return;\n      case \"paused\":\n      case \"disconnected\":\n        // If we're disconnected so switch the state to \"stopped\" so the reconnect\n        // timeout doesn't create a new WebSocket.\n        // If we're paused prevent a resume.\n        this.socket = { state: \"stopped\" };\n        return;\n      case \"stopping\":\n        await this.socket.promisePair.promise;\n        return;\n      default: {\n        // Enforce that the switch-case is exhaustive.\n        const _: never = this.socket;\n      }\n    }\n  }\n\n  async pause(): Promise<void> {\n    switch (this.socket.state) {\n      case \"stopping\":\n      case \"stopped\":\n        // If we're stopping we ignore pause\n        return;\n      case \"paused\":\n        return;\n      case \"connecting\":\n      case \"ready\":\n        this.socket.ws.close();\n        this.socket = {\n          state: \"pausing\",\n          promisePair: promisePair(),\n        };\n        await this.socket.promisePair.promise;\n        return;\n      case \"closing\":\n        // We're already closing the WebSocket, so just upgrade the state\n        // to \"pausing\" so we don't reconnect.\n        this.socket = {\n          state: \"pausing\",\n          promisePair: promisePair(),\n        };\n        await this.socket.promisePair.promise;\n        return;\n      case \"disconnected\":\n        // We're disconnected so switch the state to \"paused\" so the reconnect\n        // timeout doesn't create a new WebSocket.\n        this.socket = { state: \"paused\" };\n        return;\n      case \"pausing\":\n        await this.socket.promisePair.promise;\n        return;\n      default: {\n        // Enforce that the switch-case is exhaustive.\n        const _: never = this.socket;\n      }\n    }\n  }\n\n  /**\n   * Create a new WebSocket after a previous `pause()`, unless `stop()` was\n   * called before.\n   */\n  async resume(): Promise<void> {\n    switch (this.socket.state) {\n      case \"pausing\":\n      case \"paused\":\n        break;\n      case \"stopping\":\n      case \"stopped\":\n        // If we're stopping we ignore resume\n        return;\n      case \"connecting\":\n      case \"ready\":\n      case \"closing\":\n      case \"disconnected\":\n        throw new Error(\"`resume()` is only valid after `pause()`\");\n      default: {\n        // Enforce that the switch-case is exhaustive.\n        const _: never = this.socket;\n      }\n    }\n    if (this.socket.state === \"pausing\") {\n      await this.socket.promisePair.promise;\n    }\n    await this.connect();\n  }\n\n  private _logVerbose(message: string) {\n    if (this.verbose) {\n      console.debug(`${new Date().toISOString()} ${message}`);\n    }\n  }\n\n  private nextBackoff(): number {\n    const baseBackoff = this.initialBackoff * Math.pow(2, this.retries);\n    this.retries += 1;\n    const actualBackoff = Math.min(baseBackoff, this.maxBackoff);\n    const jitter = actualBackoff * (Math.random() - 0.5);\n    return actualBackoff + jitter;\n  }\n}\n", "export function newSessionId() {\n  return uuidv4();\n}\n\n// From https://stackoverflow.com/a/2117523\nfunction uuidv4() {\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, c => {\n    const r = (Math.random() * 16) | 0,\n      v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n", "import { GenericAPI } from \"../../api/index.js\";\nimport { version } from \"../../index.js\";\nimport { convexToJson, JSONValue, Value } from \"../../values/index.js\";\nimport { logFatalError } from \"../logging.js\";\nimport { LocalSyncState } from \"./local_state.js\";\nimport { RequestManager } from \"./request_manager.js\";\nimport {\n  OptimisticLocalStore,\n  OptimisticUpdate,\n} from \"./optimistic_updates.js\";\nimport {\n  OptimisticQueryResults,\n  QueryResultsMap,\n} from \"./optimistic_updates_impl.js\";\nimport {\n  ActionRequest,\n  AuthError,\n  MutationRequest,\n  QueryId,\n  QueryJournal,\n  RequestId,\n  ServerMessage,\n  UserIdentityAttributes,\n} from \"./protocol.js\";\nimport { QueryResult, RemoteQuerySet } from \"./remote_query_set.js\";\nimport { QueryToken, serializePathAndArgs } from \"./udf_path_utils.js\";\nimport { ReconnectMetadata, WebSocketManager } from \"./web_socket_manager.js\";\nimport { newSessionId } from \"./session.js\";\n\n/**\n * Options for {@link InternalConvexClient}.\n *\n * @public\n */\nexport interface ClientOptions {\n  /**\n   * Whether to prompt the user if they have unsaved changes pending\n   * when navigating away or closing a web page.\n   *\n   * This is only possible when the `window` object exists, i.e. in a browser.\n   *\n   * The default value is `true` in browsers.\n   */\n  unsavedChangesWarning?: boolean;\n  /**\n   * Specifies an alternate\n   * [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)\n   * constructor to use for client communication with the Convex cloud.\n   * The default behavior is to use `WebSocket` from the global environment.\n   */\n  webSocketConstructor?: typeof WebSocket;\n  /**\n   * Adds additional logging for debugging purposes.\n   *\n   * The default value is `false`.\n   */\n  verbose?: boolean;\n}\n\n/**\n * State describing the client's connection with the Convex backend.\n *\n * @public\n */\nexport type ConnectionState = {\n  hasInflightRequests: boolean;\n  isWebSocketConnected: boolean;\n};\n\n/**\n * An async function returning the JWT-encoded OpenID Connect Identity Token\n * if available.\n * See {@link ConvexReactClient.setAuth}.\n *\n * @public\n */\nexport type AuthTokenFetcher = () => Promise<string | null | undefined>;\n\n/**\n * Low-level client for directly integrating state management libraries\n * with Convex.\n *\n * Most developers should use higher level clients, like\n * the {@link ConvexHttpClient} or the React hook based {@link react.ConvexReactClient}.\n *\n * @public\n */\nexport class InternalConvexClient {\n  private readonly state: LocalSyncState;\n  private readonly requestManager: RequestManager;\n  private readonly webSocketManager: WebSocketManager;\n  private remoteQuerySet: RemoteQuerySet;\n  private readonly optimisticQueryResults: OptimisticQueryResults;\n  private readonly onTransition: (updatedQueries: QueryToken[]) => void;\n  private nextRequestId: RequestId;\n  private readonly sessionId: string;\n  private fetchToken: null | (() => Promise<string | null | undefined>) = null;\n\n  /**\n   * @param address - The url of your Convex deployment, often provided\n   * by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.\n   * @param onTransition - A callback receiving an array of query tokens\n   * corresponding to query results that have changed.\n   * @param options - See {@link ClientOptions} for a full description.\n   */\n  constructor(\n    address: string,\n    onTransition: (updatedQueries: QueryToken[]) => void,\n    options?: ClientOptions\n  ) {\n    if (typeof address === \"object\") {\n      throw new Error(\n        \"Passing a ClientConfig object is no longer supported. Pass the URL of the Convex deployment as a string directly.\"\n      );\n    }\n    options = { ...options };\n    let webSocketConstructor = options.webSocketConstructor;\n    if (!webSocketConstructor && typeof WebSocket === \"undefined\") {\n      throw new Error(\n        \"No WebSocket global variable defined! To use Convex in an environment without WebSocket try the HTTP client: https://docs.convex.dev/api/classes/browser.ConvexHttpClient\"\n      );\n    }\n    webSocketConstructor = webSocketConstructor || WebSocket;\n    const verbose = options.verbose ?? false;\n\n    // Substitute http(s) with ws(s)\n    const i = address.search(\"://\");\n    if (i === -1) {\n      throw new Error(\"Provided address was not an absolute URL.\");\n    }\n    const origin = address.substring(i + 3); // move past the double slash\n    const protocol = address.substring(0, i);\n    let wsProtocol;\n    if (protocol === \"http\") {\n      wsProtocol = \"ws\";\n    } else if (protocol === \"https\") {\n      wsProtocol = \"wss\";\n    } else {\n      throw new Error(`Unknown parent protocol ${protocol}`);\n    }\n    const wsUri = `${wsProtocol}://${origin}/api/${version}/sync`;\n\n    this.state = new LocalSyncState();\n    this.remoteQuerySet = new RemoteQuerySet(queryId =>\n      this.state.queryPath(queryId)\n    );\n    this.requestManager = new RequestManager();\n    this.optimisticQueryResults = new OptimisticQueryResults();\n    this.onTransition = onTransition;\n    this.nextRequestId = 0;\n    this.sessionId = newSessionId();\n\n    const { unsavedChangesWarning } = options;\n    if (typeof window === \"undefined\") {\n      if (unsavedChangesWarning === true) {\n        throw new Error(\n          \"unsavedChangesWarning requested, but no window object found! Remove {unsavedChangesWarning: true} from Convex client options.\"\n        );\n      }\n    } else if (unsavedChangesWarning !== false) {\n      // Listen for tab close events and notify the user on unsaved changes.\n      window.addEventListener(\"beforeunload\", e => {\n        if (this.requestManager.hasIncompleteRequests()) {\n          // There are 3 different ways to trigger this pop up so just try all of\n          // them.\n\n          e.preventDefault();\n          // This confirmation message doesn't actually appear in most modern\n          // browsers but we tried.\n          const confirmationMessage =\n            \"Are you sure you want to leave? Your changes may not be saved.\";\n          (e || window.event).returnValue = confirmationMessage;\n          return confirmationMessage;\n        }\n      });\n    }\n\n    this.webSocketManager = new WebSocketManager(\n      wsUri,\n      (reconnectMetadata: ReconnectMetadata) => {\n        // We have a new WebSocket!\n\n        this.webSocketManager.sendMessage({\n          ...reconnectMetadata,\n          type: \"Connect\",\n          sessionId: this.sessionId,\n        });\n\n        // Throw out our remote query, reissue queries\n        // and outstanding mutations, and reauthenticate.\n        this.remoteQuerySet = new RemoteQuerySet(queryId =>\n          this.state.queryPath(queryId)\n        );\n        const [querySetModification, authModification] = this.state.restart();\n        if (authModification) {\n          this.webSocketManager.sendMessage(authModification);\n        }\n        this.webSocketManager.sendMessage(querySetModification);\n        for (const message of this.requestManager.restart()) {\n          this.webSocketManager.sendMessage(message);\n        }\n      },\n      (serverMessage: ServerMessage) => {\n        switch (serverMessage.type) {\n          case \"Transition\": {\n            this.remoteQuerySet.transition(serverMessage);\n            this.state.saveQueryJournals(serverMessage);\n            const completedRequests = this.requestManager.removeCompleted(\n              this.remoteQuerySet.timestamp()\n            );\n            this.notifyOnQueryResultChanges(completedRequests);\n            break;\n          }\n          case \"MutationResponse\": {\n            const completedMutationId =\n              this.requestManager.onResponse(serverMessage);\n            if (completedMutationId) {\n              this.notifyOnQueryResultChanges(new Set([completedMutationId]));\n            }\n            break;\n          }\n          case \"ActionResponse\": {\n            this.requestManager.onResponse(serverMessage);\n            break;\n          }\n          case \"AuthError\": {\n            this.tryToReauthenticate(serverMessage)\n              .then()\n              .catch(error => {\n                logFatalError(error);\n                // TODO(CX-3070): This ignores a failed Promise\n                void this.webSocketManager.stop();\n              });\n            break;\n          }\n          case \"FatalError\": {\n            const error = logFatalError(serverMessage.error);\n            void this.webSocketManager.stop();\n            throw error;\n          }\n          case \"Ping\":\n            break; // do nothing\n          default: {\n            const _typeCheck: never = serverMessage;\n          }\n        }\n      },\n      webSocketConstructor,\n      verbose\n    );\n  }\n\n  /**\n   * Compute the current query results based on the remoteQuerySet and the\n   * current optimistic updates and call `onTransition` for all the changed\n   * queries.\n   *\n   * @param completedMutations - A set of mutation IDs whose optimistic updates\n   * are no longer needed.\n   */\n  private notifyOnQueryResultChanges(completedRequest: Set<RequestId>) {\n    const remoteQueryResults: Map<QueryId, QueryResult> =\n      this.remoteQuerySet.remoteQueryResults();\n    const queryTokenToValue: QueryResultsMap = new Map();\n    for (const [queryId, result] of remoteQueryResults) {\n      const queryToken = this.state.queryToken(queryId);\n      // It's possible that we've already unsubscribed to this query but\n      // the server hasn't learned about that yet. If so, ignore this one.\n\n      if (queryToken !== null) {\n        const query = {\n          result,\n          udfPath: this.state.queryPath(queryId)!,\n          args: this.state.queryArgs(queryId)!,\n        };\n        queryTokenToValue.set(queryToken, query);\n      }\n    }\n\n    this.onTransition(\n      this.optimisticQueryResults.ingestQueryResultsFromServer(\n        queryTokenToValue,\n        completedRequest\n      )\n    );\n  }\n\n  async setAuth(fetchToken: AuthTokenFetcher) {\n    this.fetchToken = fetchToken;\n    const token = await fetchToken();\n    if (token) {\n      this.authenticate(token);\n    } else if (this.state.hasAuth()) {\n      this.clearAuth();\n    }\n  }\n\n  // Stop the webSocket so that we don't retry with bad auth\n  private async tryToReauthenticate(serverMessage: AuthError) {\n    if (!this.fetchToken) {\n      throw new Error(serverMessage.error);\n    }\n    console.log(\"Attempting to reauthenticate\");\n    await this.webSocketManager.pause();\n    const token = await this.fetchToken();\n    if (token && this.state.isNewAuth(token)) {\n      this.state.setAuth(token);\n    } else if (this.state.hasAuth()) {\n      console.log(\"Reauthentication failed, clearing auth\");\n      this.state.clearAuth();\n    }\n    await this.webSocketManager.resume();\n  }\n\n  hasAuth() {\n    return this.state.hasAuth();\n  }\n\n  private authenticate(token: string) {\n    const message = this.state.setAuth(token);\n    this.webSocketManager.sendMessage(message);\n  }\n\n  /** @internal */\n  setAdminAuth(value: string, fakeUserIdentity?: UserIdentityAttributes) {\n    const message = this.state.setAdminAuth(value, fakeUserIdentity);\n    this.webSocketManager.sendMessage(message);\n  }\n\n  clearAuth() {\n    const message = this.state.clearAuth();\n    this.webSocketManager.sendMessage(message);\n  }\n\n  /**\n   * Subscribe to a query function.\n   *\n   * Whenever this query's result changes, the `onTransition` callback\n   * passed into the constructor will be called.\n   *\n   * @param name - The name of the query.\n   * @param args - An array of the arguments to the query.\n   * @param journal - An (optional) journal produced from a previous\n   * execution of this query function. Note that if this query function with\n   * these arguments has already been requested the journal will have no effect.\n   * @returns An object containing a {@link QueryToken} corresponding to this\n   * query and an `unsubscribe` callback.\n   */\n  subscribe(\n    name: string,\n    args: any[],\n    journal?: QueryJournal\n  ): { queryToken: QueryToken; unsubscribe: () => void } {\n    // `subscribe` used to collect the arguments with a rest operator\n    // (like `...args`). Double check that it's an array to make sure developers\n    // have updated their code.\n    if (!Array.isArray(args)) {\n      throw new Error(\n        `Query arguments to \\`InternalConvexClient.subcribe\\` must be an array. Received ${args}.`\n      );\n    }\n\n    const { modification, queryToken, unsubscribe } = this.state.subscribe(\n      name,\n      args,\n      journal\n    );\n    if (modification !== null) {\n      this.webSocketManager.sendMessage(modification);\n    }\n    // TODO: Use FinalizationRegistry?\n    return {\n      queryToken,\n      unsubscribe: () => {\n        const modification = unsubscribe();\n        if (modification) {\n          this.webSocketManager.sendMessage(modification);\n        }\n      },\n    };\n  }\n\n  /**\n   * A query result based only on the current, local state.\n   *\n   * The only way this will return a value is if we're already subscribed to the\n   * query or its value has been set optimistically.\n   */\n  localQueryResult(udfPath: string, args: any[]): Value | undefined {\n    const queryToken = serializePathAndArgs(udfPath, args);\n    return this.optimisticQueryResults.queryResult(queryToken);\n  }\n\n  /**\n   * Retrieve the current {@link QueryJournal} for this query function.\n   *\n   * If we have not yet received a result for this query, this will be `undefined`.\n   *\n   * @param name - The name of the query.\n   * @param args - An array of arguments to this query.\n   * @returns The query's {@link QueryJournal} or `undefined`.\n   */\n  queryJournal(name: string, args: any[]): QueryJournal | undefined {\n    const queryToken = serializePathAndArgs(name, args);\n    return this.state.queryJournal(queryToken);\n  }\n\n  /**\n   * Get the current {@link ConnectionState} between the client and the Convex\n   * backend.\n   *\n   * @returns The {@link ConnectionState} with the Convex backend.\n   */\n  connectionState(): ConnectionState {\n    return {\n      hasInflightRequests: this.requestManager.hasInflightRequests(),\n      isWebSocketConnected: this.webSocketManager.socketState() === \"ready\",\n    };\n  }\n\n  async mutate<Args extends any[]>(\n    udfPath: string,\n    args: Args,\n    optimisticUpdate: OptimisticUpdate<GenericAPI, Args> | null = null\n  ): Promise<any> {\n    const requestId = this.nextRequestId;\n    this.nextRequestId++;\n\n    if (optimisticUpdate !== null) {\n      const wrappedUpdate = (localQueryStore: OptimisticLocalStore) => {\n        optimisticUpdate(localQueryStore, ...args);\n      };\n      const changedQueries = this.optimisticQueryResults.applyOptimisticUpdate(\n        wrappedUpdate,\n        requestId\n      );\n      this.onTransition(changedQueries);\n    }\n\n    const message: MutationRequest = {\n      type: \"Mutation\",\n      requestId,\n      udfPath,\n      args: convexToJson(args) as JSONValue[],\n    };\n    const mightBeSent = this.webSocketManager.sendMessage(message);\n    return this.requestManager.request(message, mightBeSent);\n  }\n\n  async action<Args extends any[]>(udfPath: string, args: Args): Promise<any> {\n    const requestId = this.nextRequestId;\n    this.nextRequestId++;\n\n    const message: ActionRequest = {\n      type: \"Action\",\n      requestId,\n      udfPath,\n      args: convexToJson(args) as JSONValue[],\n    };\n\n    const mightBeSent = this.webSocketManager.sendMessage(message);\n    return this.requestManager.request(message, mightBeSent);\n  }\n\n  async close(): Promise<void> {\n    return this.webSocketManager.stop();\n  }\n}\n", "import {\n  GenericAPI,\n  NamedAction,\n  NamedMutation,\n  NamedQuery,\n  PublicActionNames,\n  PublicMutationNames,\n  PublicQueryNames,\n} from \"../api/index.js\";\nimport { STATUS_CODE_UDF_FAILED } from \"../common/index.js\";\nimport { version } from \"../index.js\";\nimport { convexToJson, jsonToConvex } from \"../values/index.js\";\nimport { logToConsole } from \"./logging.js\";\n\n/** In browsers, Node.js 18, Deno, etc. `fetch` is a global function */\ntype WindowFetch = typeof window.fetch;\n\nconst fetch: WindowFetch =\n  globalThis.fetch ||\n  ((...args) =>\n    import(\"node-fetch\").then(({ default: fetch }) =>\n      (fetch as unknown as WindowFetch)(...args)\n    ));\n\n// TODO Typedoc doesn't generate documentation for the comment below perhaps\n// because it's a callable interface.\n/**\n * An interface to execute a Convex query function on the server.\n *\n * @public\n */\nexport interface Query<F extends (...args: any[]) => Promise<any>> {\n  /**\n   * Execute the query on the server, returning a `Promise` of the return value.\n   *\n   * @param args - Arguments for the query.\n   * @returns The result of the query.\n   */\n  (...args: Parameters<F>): Promise<Awaited<ReturnType<F>>>;\n}\n\n// TODO Typedoc doesn't generate documentation for the comment below perhaps\n// because it's a callable interface.\n/**\n * An interface to execute a Convex mutation function on the server.\n *\n * @public\n */\nexport interface Mutation<F extends (...args: any[]) => Promise<any>> {\n  /**\n   * Execute the mutation on the server, returning a `Promise` of its return value.\n   *\n   * @param args - Arguments for the mutation.\n   * @returns The return value of the server-side function call.\n   */\n  (...args: Parameters<F>): Promise<Awaited<ReturnType<F>>>;\n}\n\n// TODO Typedoc doesn't generate documentation for the comment below perhaps\n// because it's a callable interface.\n/**\n * An interface to execute a Convex action on the server.\n *\n * @public\n */\nexport interface Action<F extends (...args: any[]) => Promise<any>> {\n  /**\n   * Execute the action on the server, returning a `Promise` of its return value.\n   *\n   * @param args - Arguments for the action.\n   * @returns The return value of the server-side action call.\n   */\n  (...args: Parameters<F>): Promise<Awaited<ReturnType<F>>>;\n}\n\n/**\n * A Convex client that runs queries and mutations over HTTP.\n *\n * This is appropriate for server-side code (like Netlify Lambdas) or non-reactive\n * webapps.\n *\n * If you're building a React app, consider using\n * {@link react.ConvexReactClient} instead.\n *\n *\n * @public\n */\nexport class ConvexHttpClient<API extends GenericAPI> {\n  private readonly address: string;\n  private auth?: string;\n  private debug: boolean;\n  constructor(address: string) {\n    this.address = `${address}/api`;\n    this.debug = true;\n  }\n\n  /**\n   * Obtain the {@link ConvexHttpClient}'s URL to its backend.\n   *\n   * @returns The URL to the Convex backend, including the client's API version.\n   */\n  backendUrl(): string {\n    return this.address;\n  }\n\n  /**\n   * Set the authentication token to be used for subsequent queries and mutations.\n   *\n   * Should be called whenever the token changes (i.e. due to expiration and refresh).\n   *\n   * @param value - JWT-encoded OpenID Connect identity token.\n   */\n  setAuth(value: string) {\n    this.auth = value;\n  }\n\n  /**\n   * Clear the current authentication token if set.\n   */\n  clearAuth() {\n    this.auth = undefined;\n  }\n\n  /**\n   * Sets whether the result log lines should be printed on the console or not.\n   *\n   * @internal\n   */\n  setDebug(debug: boolean) {\n    this.debug = debug;\n  }\n\n  /**\n   * Construct a new {@link Query}.\n   *\n   * @param name - The name of the query function.\n   * @returns The {@link Query} object with that name.\n   */\n  query<Name extends PublicQueryNames<API>>(name: Name) {\n    return async (\n      ...args: Parameters<NamedQuery<API, Name>>\n    ): Promise<ReturnType<NamedQuery<API, Name>>> => {\n      // Interpret the arguments as a Convex array and then serialize to JSON.\n      const body = JSON.stringify({\n        path: name,\n        args: convexToJson(args),\n        debug: this.debug,\n      });\n      const headers: Record<string, string> = {\n        \"Content-Type\": \"application/json\",\n        \"Convex-Client\": `npm-${version}`,\n      };\n      if (this.auth) {\n        headers[\"Authorization\"] = `Bearer ${this.auth}`;\n      }\n      const response = await fetch(`${this.address}/query`, {\n        body,\n        method: \"POST\",\n        headers: headers,\n        credentials: \"include\",\n      });\n      if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n        throw new Error(await response.text());\n      }\n      const respJSON = await response.json();\n\n      for (const line of respJSON.logLines ?? []) {\n        logToConsole(\"info\", \"query\", name, line);\n      }\n      switch (respJSON.status) {\n        case \"success\":\n          // Validate that the response is a valid Convex value.\n          return jsonToConvex(respJSON.value) as Awaited<\n            ReturnType<NamedQuery<API, Name>>\n          >;\n        case \"error\":\n          throw new Error(respJSON.errorMessage);\n        default:\n          throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n      }\n    };\n  }\n\n  /**\n   * Construct a new {@link Mutation}.\n   *\n   * @param name - The name of the mutation function.\n   * @returns The {@link Mutation} object with that name.\n   */\n  mutation<Name extends PublicMutationNames<API>>(name: Name) {\n    return async (\n      ...args: Parameters<NamedMutation<API, Name>>\n    ): Promise<ReturnType<NamedMutation<API, Name>>> => {\n      // Interpret the arguments as a Convex array and then serialize to JSON.\n      const body = JSON.stringify({\n        path: name,\n        args: convexToJson(args),\n        debug: this.debug,\n      });\n      const headers: Record<string, string> = {\n        \"Content-Type\": \"application/json\",\n        \"Convex-Client\": `npm-${version}`,\n      };\n      if (this.auth) {\n        headers[\"Authorization\"] = `Bearer ${this.auth}`;\n      }\n      const response = await fetch(`${this.address}/mutation`, {\n        body,\n        method: \"POST\",\n        headers: headers,\n        credentials: \"include\",\n      });\n      if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n        throw new Error(await response.text());\n      }\n      const respJSON = await response.json();\n      for (const line of respJSON.logLines ?? []) {\n        logToConsole(\"info\", \"mutation\", name, line);\n      }\n      switch (respJSON.status) {\n        case \"success\":\n          // Validate that the response is a valid Convex value.\n          return jsonToConvex(respJSON.value) as Awaited<\n            ReturnType<NamedMutation<API, Name>>\n          >;\n        case \"error\":\n          throw new Error(respJSON.errorMessage);\n        default:\n          throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n      }\n    };\n  }\n\n  /**\n   * Construct a new {@link Action}.\n   *\n   * @param name - The name of the action.\n   * @returns The {@link Action} object with that name.\n   * @public\n   */\n  action<Name extends PublicActionNames<API>>(name: Name) {\n    return async (\n      ...args: Parameters<NamedAction<API, Name>>\n    ): Promise<ReturnType<NamedAction<API, Name>>> => {\n      // Interpret the arguments as a Convex array and then serialize to JSON.\n      const body = JSON.stringify({\n        path: name,\n        args: convexToJson(args),\n        debug: this.debug,\n      });\n      const headers: Record<string, string> = {\n        \"Content-Type\": \"application/json\",\n        \"Convex-Client\": `npm-${version}`,\n      };\n      if (this.auth) {\n        headers[\"Authorization\"] = `Bearer ${this.auth}`;\n      }\n      const response = await fetch(`${this.address}/action`, {\n        body,\n        method: \"POST\",\n        headers: headers,\n        credentials: \"include\",\n      });\n      if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n        throw new Error(await response.text());\n      }\n      const respJSON = await response.json();\n      for (const line of respJSON.logLines ?? []) {\n        logToConsole(\"info\", \"action\", name, line);\n      }\n      switch (respJSON.status) {\n        case \"success\":\n          // Validate that the response is a valid Convex value.\n          return jsonToConvex(respJSON.value) as Awaited<\n            ReturnType<NamedAction<API, Name>>\n          >;\n        case \"error\":\n          throw new Error(respJSON.errorMessage);\n        default:\n          throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n      }\n    };\n  }\n}\n", "/**\n * Tools to integrate Convex into React applications.\n *\n * This module contains:\n * 1. {@link ConvexReactClient}, a client for using Convex in React.\n * 2. {@link ConvexProvider}, a component that stores this client in React context.\n * 3. {@link Authenticated}, {@link Unauthenticated} and {@link AuthLoading} helper auth components.\n * 4. [Hooks](https://docs.convex.dev/generated-api/react#react-hooks) for calling into\n *    this client within your React components.\n *\n * ## Usage\n *\n * ### Creating the client\n *\n * ```typescript\n * import { ConvexReactClient } from \"convex/react\";\n *\n * // typically loaded from an environment variable\n * const address = \"https://small-mouse-123.convex.cloud\"\n * const convex = new ConvexReactClient(address);\n * ```\n *\n * ### Storing the client in React Context\n *\n * ```typescript\n * import { ConvexProvider } from \"convex/react\";\n *\n * <ConvexProvider client={convex}>\n *   <App />\n * </ConvexProvider>\n * ```\n *\n * ### Using the auth helpers\n *\n * ```typescript\n * import { Authenticated, Unauthenticated, AuthLoading } from \"convex/react\";\n *\n * <Authenticated>\n *   Logged in\n * </Authenticated>\n * <Unauthenticated>\n *   Logged out\n * </Unauthenticated>\n * <AuthLoading>\n *   Still loading\n * </AuthLoading>\n * ```\n *\n * ### Generating typed hooks\n *\n * This module is typically used alongside generated hooks.\n *\n * To generate the hooks, run `npx convex dev` in your Convex project. This\n * will create a `convex/_generated/react.js` file with the following React\n * hooks, typed for your queries and mutations:\n * - [useQuery](https://docs.convex.dev/generated-api/react#usequery)\n * - [useMutation](https://docs.convex.dev/generated-api/react#usemutation)\n * - [useConvex](https://docs.convex.dev/generated-api/react#useconvex)\n * - [usePaginatedQuery](https://docs.convex.dev/generated-api/react#usepaginatedquery)\n * - [useQueries](https://docs.convex.dev/generated-api/react#usequeries)\n *\n * If you aren't using code generation, you can use these untyped hooks instead:\n * - {@link useQueryGeneric}\n * - {@link useMutationGeneric}\n * - {@link useConvexGeneric}\n * - {@link usePaginatedQueryGeneric}\n * - {@link useQueriesGeneric}\n *\n * ### Using the hooks\n *\n * ```typescript\n * import { useQuery, useMutation } from \"../convex/_generated/react\";\n *\n * function App() {\n *   const counter = useQuery(\"getCounter\");\n *   const increment = useMutation(\"incrementCounter\");\n *   // Your component here!\n * }\n * ```\n * @module\n */\n\nimport {\n  GenericAPI,\n  InternalConvexClient,\n  NamedMutation,\n  NamedQuery,\n  NamedAction,\n  PublicQueryNames,\n  PublicMutationNames,\n  PublicActionNames,\n} from \"../browser/index.js\";\nimport type { OptimisticUpdate, QueryToken } from \"../browser/index.js\";\nimport React, { useContext, useMemo } from \"react\";\nimport { convexToJson } from \"../values/index.js\";\nimport ReactDOM from \"react-dom\";\nimport { useSubscription } from \"./use_subscription.js\";\nimport { QueryJournal } from \"../browser/sync/protocol.js\";\nimport { AuthTokenFetcher, ConnectionState } from \"../browser/sync/client.js\";\nimport type { UserIdentityAttributes } from \"../browser/sync/protocol.js\";\nexport * from \"./use_paginated_query.js\";\nexport {\n  useQueriesGeneric,\n  type RequestForQueries,\n  type UseQueriesForAPI,\n} from \"./use_queries.js\";\nexport { useUploadGeneric } from \"./use_upload.js\";\nexport type { AuthTokenFetcher } from \"../browser/sync/client.js\";\nexport * from \"./auth_helpers.js\";\nexport * from \"./ConvexAuthState.js\";\n\n// TODO add runtime check that React version is good too.\nif (typeof React === \"undefined\") {\n  throw new Error(\"Required dependency 'react' not installed\");\n}\nif (typeof ReactDOM === \"undefined\") {\n  throw new Error(\"Required dependency 'react-dom' not installed\");\n}\n\n// TODO Typedoc doesn't generate documentation for the comment below perhaps\n// because it's a callable interface.\n/**\n * An interface to execute a Convex mutation function on the server.\n *\n * @public\n */\nexport interface ReactMutation<\n  API extends GenericAPI,\n  Name extends PublicMutationNames<API>\n> {\n  /**\n   * Execute the mutation on the server, returning a `Promise` of its return value.\n   *\n   * @param args - Arguments for the mutation to pass up to the server.\n   * @returns The return value of the server-side function call.\n   */\n  (...args: Parameters<NamedMutation<API, Name>>): Promise<\n    ReturnType<NamedMutation<API, Name>>\n  >;\n\n  /**\n   * Define an optimistic update to apply as part of this mutation.\n   *\n   * This is a temporary update to the local query results to facilitate a\n   * fast, interactive UI. It enables query results to update before a mutation\n   * executed on the server.\n   *\n   * When the mutation is invoked, the optimistic update will be applied.\n   *\n   * Optimistic updates can also be used to temporarily remove queries from the\n   * client and create loading experiences until a mutation completes and the\n   * new query results are synced.\n   *\n   * The update will be automatically rolled back when the mutation is fully\n   * completed and queries have been updated.\n   *\n   * @param optimisticUpdate - The optimistic update to apply.\n   * @returns A new `ReactMutation` with the update configured.\n   *\n   * @public\n   */\n  withOptimisticUpdate(\n    optimisticUpdate: OptimisticUpdate<\n      API,\n      Parameters<NamedMutation<API, Name>>\n    >\n  ): ReactMutation<API, Name>;\n}\n\nfunction createMutation<\n  API extends GenericAPI,\n  Name extends PublicMutationNames<API>\n>(\n  name: Name,\n  sync: () => InternalConvexClient,\n  update: OptimisticUpdate<\n    API,\n    Parameters<NamedMutation<API, Name>>\n  > | null = null\n): ReactMutation<API, Name> {\n  function mutation(\n    ...args: Parameters<NamedMutation<API, Name>>\n  ): Promise<ReturnType<NamedMutation<API, Name>>> {\n    assertNotAccidentalArgument(args);\n    return sync().mutate(name, args, update);\n  }\n  mutation.withOptimisticUpdate = function withOptimisticUpdate(\n    optimisticUpdate: OptimisticUpdate<\n      API,\n      Parameters<NamedMutation<API, Name>>\n    >\n  ): ReactMutation<API, Name> {\n    if (update !== null) {\n      throw new Error(\n        `Already specified optimistic update for mutation ${name}`\n      );\n    }\n    return createMutation(name, sync, optimisticUpdate);\n  };\n  return mutation;\n}\n\n/**\n * An interface to execute a Convex action on the server.\n *\n * @public\n */\nexport interface ReactAction<\n  API extends GenericAPI,\n  Name extends PublicActionNames<API>\n> {\n  /**\n   * Execute the function on the server, returning a `Promise` of its return value.\n   *\n   * @param args - Arguments for the function to pass up to the server.\n   * @returns The return value of the server-side function call.\n   * @public\n   */\n  (...args: Parameters<NamedAction<API, Name>>): Promise<\n    ReturnType<NamedAction<API, Name>>\n  >;\n}\n\nfunction createAction<\n  API extends GenericAPI,\n  Name extends PublicActionNames<API>\n>(name: Name, sync: () => InternalConvexClient): ReactAction<API, Name> {\n  return function (\n    ...args: Parameters<NamedAction<API, Name>>\n  ): Promise<ReturnType<NamedAction<API, Name>>> {\n    return sync().action(name, args);\n  };\n}\n\n/**\n * A watch on the output of a Convex query function.\n *\n * @public\n */\nexport interface Watch<T> {\n  /**\n   * Initiate a watch on the output of a query.\n   *\n   * This will subscribe to this query and call\n   * the callback whenever the query result changes.\n   *\n   * **Important: If the query is already known on the client this watch will\n   * never be invoked.** To get the current, local result call\n   * {@link react.Watch.localQueryResult}.\n   *\n   * @param callback - Function that is called whenever the query result changes.\n   * @returns - A function that disposes of the subscription.\n   */\n  onUpdate(callback: () => void): () => void;\n\n  /**\n   * Get the current result of a query.\n   *\n   * This will only return a result if we're already subscribed to the query\n   * and have received a result from the server or the query value has been set\n   * optimistically.\n   *\n   * @returns The result of the query or `undefined` if it isn't known.\n   * @throws An error if the query encountered an error on the server.\n   */\n  localQueryResult(): T | undefined;\n\n  /**\n   * Get the current {@link browser.QueryJournal} for this query.\n   *\n   * If we have not yet received a result for this query, this will be `undefined`.\n   */\n  journal(): QueryJournal | undefined;\n}\n\n/**\n * Options for {@link ConvexReactClient}.\n *\n * @public\n */\nexport interface ReactClientOptions {\n  /**\n   * Whether to prompt the user if they have unsaved changes pending\n   * when navigating away or closing a web page.\n   *\n   * This is only possible when the `window` object exists, i.e. in a browser.\n   *\n   * The default value is `true`.\n   */\n  unsavedChangesWarning?: boolean;\n  /**\n   * Specifies an alternate [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket) constructor to use for client communication with the Convex cloud. The default behavior is to use `WebSocket` from the global environment.\n   */\n  webSocketConstructor?: typeof WebSocket;\n  /**\n   * Adds additional logging for debugging purposes.\n   *\n   * The default value is `false`.\n   */\n  verbose?: boolean;\n}\n\n/**\n * A Convex client for use within React.\n *\n * This loads reactive queries and executes mutations over a WebSocket.\n *\n * @typeParam API - The API of your application, composed of all Convex queries\n * and mutations. `npx convex codegen` [generates this type](/generated-api/react#convexapi)\n * in `convex/_generated/react.d.ts`.\n * @public\n */\nexport class ConvexReactClient<API extends GenericAPI> {\n  private address: string;\n  private cachedSync?: InternalConvexClient;\n  private listeners: Map<QueryToken, Set<() => void>>;\n  private options: ReactClientOptions;\n  private closed = false;\n\n  private adminAuth?: string;\n  private fakeUserIdentity?: UserIdentityAttributes;\n\n  /**\n   * @param address - The url of your Convex deployment, often provided\n   * by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.\n   * @param options - See {@link ReactClientOptions} for a full description.\n   */\n  constructor(address: string, options?: ReactClientOptions) {\n    // Validate address immediately since validation by the lazily-instantiated\n    // internal client does not occur synchronously.\n    if (typeof address !== \"string\") {\n      throw new Error(\n        \"ConvexReactClient requires a URL like 'https://happy-otter-123.convex.cloud'.\"\n      );\n    }\n    if (!address.includes(\"://\")) {\n      throw new Error(\"Provided address was not an absolute URL.\");\n    }\n    this.address = address;\n    this.listeners = new Map();\n    this.options = { ...options };\n  }\n\n  /**\n   * Lazily instantiate the `InternalConvexClient` so we don't create the WebSocket\n   * when server-side rendering.\n   */\n  private get sync() {\n    if (this.closed) {\n      throw new Error(\"ConvexReactClient has already been closed.\");\n    }\n    if (this.cachedSync) {\n      return this.cachedSync;\n    }\n    this.cachedSync = new InternalConvexClient(\n      this.address,\n      updatedQueries => this.transition(updatedQueries),\n      this.options\n    );\n    if (this.adminAuth) {\n      this.cachedSync.setAdminAuth(this.adminAuth, this.fakeUserIdentity);\n    }\n    return this.cachedSync;\n  }\n\n  /**\n   * Set the authentication token to be used for subsequent queries and mutations.\n   * `fetchToken` will be called automatically again if a token expires.\n   * `fetchToken` should return `null` if the token cannot be retrieved, for example\n   * when the user's rights were permanently revoked.\n   * @param fetchToken - an async function returning the JWT-encoded OpenID Connect Identity Token\n   */\n  async setAuth(fetchToken: AuthTokenFetcher): Promise<void> {\n    if (typeof fetchToken === \"string\") {\n      throw new Error(\n        \"Passing a string to ConvexReactClient.setAuth is no longer supported, \" +\n          \"please upgrade to passing in an async function to handle reauthentication.\"\n      );\n    }\n    return await this.sync.setAuth(fetchToken);\n  }\n\n  /**\n   * Clear the current authentication token if set.\n   */\n  clearAuth() {\n    this.sync.clearAuth();\n  }\n\n  /**\n   * @internal\n   */\n  setAdminAuth(token: string, identity?: UserIdentityAttributes) {\n    this.adminAuth = token;\n    this.fakeUserIdentity = identity;\n    if (this.closed) {\n      throw new Error(\"ConvexReactClient has already been closed.\");\n    }\n    if (this.cachedSync) {\n      this.sync.setAdminAuth(token, identity);\n    }\n  }\n\n  /**\n   * Construct a new {@link Watch} on a Convex query function.\n   *\n   * **Most application code should not call this method directly. Instead use\n   * the `useQuery` hook generated by `npx convex codegen`.**\n   *\n   * @param name - The name of the query function.\n   * @param args - The arguments to the query.\n   * @param journal - An (optional) {@link browser.QueryJournal} to use while\n   * executing this query. Note that if this query function with these arguments\n   * has already been requested, the journal will have no effect.\n   * @returns The {@link Watch} object.\n   */\n  watchQuery<Name extends PublicQueryNames<API>>(\n    name: Name,\n    args: Parameters<NamedQuery<API, Name>>,\n    journal?: QueryJournal\n  ): Watch<ReturnType<NamedQuery<API, Name>>> {\n    // `watchQuery` used to collect the arguments with a rest operator\n    // (like `...args`). Double check that it's an array to make sure developers\n    // have updated their code.\n    if (!Array.isArray(args)) {\n      throw new Error(\n        `Query arguments to \\`ConvexReactClient.watchQuery\\` must be an array. Received ${args}.`\n      );\n    }\n    return {\n      onUpdate: callback => {\n        const { queryToken, unsubscribe } = this.sync.subscribe(\n          name as string,\n          args,\n          journal\n        );\n\n        const currentListeners = this.listeners.get(queryToken);\n        if (currentListeners !== undefined) {\n          currentListeners.add(callback);\n        } else {\n          this.listeners.set(queryToken, new Set([callback]));\n        }\n\n        return () => {\n          if (this.closed) {\n            return;\n          }\n\n          const currentListeners = this.listeners.get(queryToken)!;\n          currentListeners.delete(callback);\n          if (currentListeners.size === 0) {\n            this.listeners.delete(queryToken);\n          }\n          unsubscribe();\n        };\n      },\n\n      localQueryResult: () => {\n        // Use the cached client because we can't have a query result if we don't\n        // even have a client yet!\n        if (this.cachedSync) {\n          return this.cachedSync.localQueryResult(name, args) as ReturnType<\n            NamedQuery<API, Name>\n          >;\n        }\n        return undefined;\n      },\n\n      journal: () => {\n        if (this.cachedSync) {\n          return this.cachedSync.queryJournal(name, args);\n        }\n        return undefined;\n      },\n    };\n  }\n\n  /**\n   * Construct a new {@link ReactMutation}.\n   *\n   * @param name - The name of the Mutation.\n   * @returns The {@link ReactMutation} object with that name.\n   */\n  mutation<Name extends PublicMutationNames<API>>(\n    name: Name\n  ): ReactMutation<API, Name> {\n    return createMutation(name, () => this.sync);\n  }\n\n  /**\n   * Construct a new {@link ReactAction}\n   *\n   * @param name - The name of the Action.\n   * @returns The {@link ReactAction} object with that name.\n   */\n  action<Name extends PublicActionNames<API>>(\n    name: Name\n  ): ReactAction<API, Name> {\n    return createAction(name, () => this.sync);\n  }\n\n  /**\n   * Get the current {@link ConnectionState} between the client and the Convex\n   * backend.\n   *\n   * @returns The {@link ConnectionState} with the Convex backend.\n   */\n  connectionState(): ConnectionState {\n    return this.sync.connectionState();\n  }\n\n  /**\n   * Close any network handles associated with this client and stop all subscriptions.\n   *\n   * Call this method when you're done with a {@link ConvexReactClient} to\n   * dispose of its sockets and resources.\n   *\n   * @returns A `Promise` fulfilled when the connection has been completely closed.\n   */\n  async close(): Promise<void> {\n    this.closed = true;\n    // Prevent outstanding React batched updates from invoking listeners.\n    this.listeners = new Map();\n    if (this.cachedSync) {\n      const sync = this.cachedSync;\n      this.cachedSync = undefined;\n      await sync.close();\n    }\n  }\n\n  private transition(updatedQueries: QueryToken[]) {\n    ReactDOM.unstable_batchedUpdates(() => {\n      for (const queryToken of updatedQueries) {\n        const callbacks = this.listeners.get(queryToken);\n        if (callbacks) {\n          for (const callback of callbacks) {\n            callback();\n          }\n        }\n      }\n    });\n  }\n}\n\nconst ConvexContext = React.createContext<ConvexReactClient<any>>(\n  undefined as unknown as ConvexReactClient<any> // in the future this will be a mocked client for testing\n);\n\n/**\n * Get the {@link ConvexReactClient} within a React component.\n *\n * This relies on the {@link ConvexProvider} being above in the React component tree.\n *\n * If you're using code generation, use the `useConvex` function in\n * `convex/_generated/react.js` which is typed for your API.\n *\n * @returns The active {@link ConvexReactClient} object, or `undefined`.\n *\n * @public\n */\nexport function useConvexGeneric<\n  API extends GenericAPI\n>(): ConvexReactClient<API> {\n  return useContext(ConvexContext);\n}\n\n/**\n * Provides an active Convex {@link ConvexReactClient} to descendants of this component.\n *\n * Wrap your app in this component to use Convex hooks `useQuery`,\n * `useMutation`, and `useConvex`.\n *\n * @param props - an object with a `client` property that refers to a {@link ConvexReactClient}.\n *\n * @public\n */\nexport const ConvexProvider: React.FC<{\n  client: ConvexReactClient<any>;\n  children?: React.ReactNode;\n}> = ({ client, children }) => {\n  return React.createElement(\n    ConvexContext.Provider,\n    { value: client },\n    children\n  );\n};\n\n/**\n * Load a reactive query within a React component.\n *\n * This React hook contains internal state that will cause a rerender\n * whenever the query result changes.\n *\n * Throws an error if not used under {@link ConvexProvider}.\n *\n * If you're using code generation, use the `useQuery` function in\n * `convex/_generated/react.js` which is typed for your API.\n *\n * @param name - The name of the query function.\n * @param args - The arguments to the query function.\n * @returns `undefined` if loading and the query's return value otherwise.\n *\n * @public\n */\nexport function useQueryGeneric<\n  API extends GenericAPI,\n  Name extends PublicQueryNames<API>\n>(\n  name: Name,\n  ...args: Parameters<NamedQuery<API, Name>>\n): ReturnType<NamedQuery<API, Name>> | undefined {\n  const convex = useContext(ConvexContext);\n  if (convex === undefined) {\n    throw new Error(\n      \"Could not find Convex client! `useQuery` must be used in the React component \" +\n        \"tree under `ConvexProvider`. Did you forget it? \" +\n        \"See https://docs.convex.dev/quick-start#set-up-convex-in-your-react-app\"\n    );\n  }\n\n  return useQueryInternal(convex, name, ...args);\n}\n\n/**\n * @param convex - A {@link ConvexReactClient}.\n * @param name - The name of the query function.\n * @param args - The arguments to the query function.\n * @returns `undefined` if loading and the query's return value otherwise.\n *\n * @internal\n */\nexport function useQueryInternal<\n  API extends GenericAPI,\n  Name extends PublicQueryNames<API>\n>(\n  convex: ConvexReactClient<API>,\n  name: Name,\n  ...args: Parameters<NamedQuery<API, Name>>\n): ReturnType<NamedQuery<API, Name>> | undefined {\n  const subscription = useMemo(\n    () => {\n      const watch = convex.watchQuery(name, args);\n      return {\n        getCurrentValue: () => watch.localQueryResult(),\n        subscribe: (callback: () => void) => watch.onUpdate(callback),\n      };\n    },\n    // ESLint doesn't like that we're stringifying the args. We do this because\n    // we want to avoid recreating the subscription if the args are a different\n    // object that serializes to the same result.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [name, convex, JSON.stringify(convexToJson(args))]\n  );\n\n  const queryResult = useSubscription(subscription);\n  return queryResult;\n}\n\n/**\n * Construct a new {@link ReactMutation}.\n *\n * Mutation objects can be called like functions to request execution of the\n * corresponding Convex function, or further configured with\n * [optimistic updates](https://docs.convex.dev/using/optimistic-updates).\n *\n * The value returned by this hook is stable across renders, so it can be used\n * by React dependency arrays and memoization logic relying on object identity\n * without causing rerenders.\n *\n * If you're using code generation, use the `useMutation` function in\n * `convex/_generated/react.js` which is typed for your API.\n *\n * Throws an error if not used under {@link ConvexProvider}.\n *\n * @param name - The name of the mutation.\n * @returns The {@link ReactMutation} object with that name.\n *\n * @public\n */\nexport function useMutationGeneric<\n  API extends GenericAPI,\n  Name extends PublicMutationNames<API>\n>(name: Name): ReactMutation<API, Name> {\n  const convex = useContext(ConvexContext);\n  if (convex === undefined) {\n    throw new Error(\n      \"Could not find Convex client! `useMutation` must be used in the React component \" +\n        \"tree under `ConvexProvider`. Did you forget it? \" +\n        \"See https://docs.convex.dev/quick-start#set-up-convex-in-your-react-app\"\n    );\n  }\n  return useMemo(() => convex.mutation(name), [convex, name]);\n}\n\n/**\n * Construct a new {@link ReactAction}.\n *\n * Action objects can be called like functions to request execution of the\n * corresponding Convex function.\n *\n * The value returned by this hook is stable across renders, so it can be used\n * by React dependency arrays and memoization logic relying on object identity\n * without causing rerenders.\n *\n * If you're using code generation, use the `useAction` function in\n * `convex/_generated/react.js` which is typed for your API.\n *\n * Throws an error if not used under {@link ConvexProvider}.\n *\n * @param name - The name of the action.\n * @returns The {@link ReactAction} object with that name.\n *\n * @public\n */\nexport function useActionGeneric<\n  API extends GenericAPI,\n  Name extends PublicActionNames<API>\n>(name: Name): ReactAction<API, Name> {\n  const convex = useContext(ConvexContext);\n  if (convex === undefined) {\n    throw new Error(\n      \"Could not find Convex client! `useAction` must be used in the React component \" +\n        \"tree under `ConvexProvider`. Did you forget it? \" +\n        \"See https://docs.convex.dev/quick-start#set-up-convex-in-your-react-app\"\n    );\n  }\n  return useMemo(() => convex.action(name), [convex, name]);\n}\n\n/**\n * Internal type helper used by Convex code generation.\n *\n * Used to give {@link useQueryGeneric} a type specific to your API.\n * @public\n */\nexport type UseQueryForAPI<API extends GenericAPI> = <\n  Name extends PublicQueryNames<API>\n>(\n  name: Name,\n  ...args: Parameters<NamedQuery<API, Name>>\n) => ReturnType<NamedQuery<API, Name>> | undefined;\n\n/**\n * Internal type helper used by Convex code generation.\n *\n * Used to give {@link useMutationGeneric} a type specific to your API.\n * @public\n */\nexport type UseMutationForAPI<API extends GenericAPI> = <\n  Name extends PublicMutationNames<API>\n>(\n  name: Name\n) => ReactMutation<API, Name>;\n\n/**\n * Internal type helper used by Convex code generation.\n *\n * Used to give {@link useMutationGeneric} a type specific to your API.\n * @public\n */\nexport type UseActionForAPI<API extends GenericAPI> = <\n  Name extends PublicActionNames<API>\n>(\n  name: Name\n) => ReactAction<API, Name>;\n\n/**\n * Internal type helper used by Convex code generation.\n *\n * Used to give {@link useConvexGeneric} a type specific to your API.\n * @public\n */\nexport type UseConvexForAPI<API extends GenericAPI> =\n  () => ConvexReactClient<API>;\n\n// When a function is called with a single argument that looks like a\n// React SyntheticEvent it was likely called as an event handler.\nfunction assertNotAccidentalArgument(args: any[]) {\n  if (args.length !== 1) return;\n  const [value] = args;\n  // these are properties of a React.SyntheticEvent\n  // https://reactjs.org/docs/events.html\n  if (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"bubbles\" in value &&\n    \"persist\" in value &&\n    \"isDefaultPrevented\" in value\n  ) {\n    throw new Error(\n      `Convex function called with SyntheticEvent object. Did you use a Convex function as an event handler directly? Event handlers like onClick receive an event object as their first argument. These SyntheticEvent objects are not valid Convex values. Try wrapping the function like \\`const handler = () => myMutation();\\` and using \\`handler\\` in the event handler.`\n    );\n  }\n}\n", "import { useEffect, useState } from \"react\";\n\n/**\n * This code is taken from https://gist.github.com/bvaughn/e25397f70e8c65b0ae0d7c90b731b189\n * because correct subscriptions in async React is complex!\n */\n\n// Hook used for safely managing subscriptions in concurrent mode.\n//\n// In order to avoid removing and re-adding subscriptions each time this hook is called,\n// the parameters passed to this hook should be memoized in some way\u2013\n// either by wrapping the entire params object with useMemo()\n// or by wrapping the individual callbacks with useCallback().\nexport function useSubscription<Value>({\n  // (Synchronously) returns the current value of our subscription.\n  getCurrentValue,\n\n  // This function is passed an event handler to attach to the subscription.\n  // It should return an unsubscribe function that removes the handler.\n  subscribe,\n}: {\n  getCurrentValue: () => Value;\n  subscribe: (callback: () => void) => () => void;\n}): Value {\n  // Read the current value from our subscription.\n  // When this value changes, we'll schedule an update with React.\n  // It's important to also store the hook params so that we can check for staleness.\n  // (See the comment in checkForUpdates() below for more info.)\n  const [state, setState] = useState(() => ({\n    getCurrentValue,\n    subscribe,\n    value: getCurrentValue(),\n  }));\n\n  let valueToReturn = state.value;\n\n  // If parameters have changed since our last render, schedule an update with its current value.\n  if (\n    state.getCurrentValue !== getCurrentValue ||\n    state.subscribe !== subscribe\n  ) {\n    // If the subscription has been updated, we'll schedule another update with React.\n    // React will process this update immediately, so the old subscription value won't be committed.\n    // It is still nice to avoid returning a mismatched value though, so let's override the return value.\n    valueToReturn = getCurrentValue();\n\n    setState({\n      getCurrentValue,\n      subscribe,\n      value: valueToReturn,\n    });\n  }\n\n  // It is important not to subscribe while rendering because this can lead to memory leaks.\n  // (Learn more at reactjs.org/docs/strict-mode.html#detecting-unexpected-side-effects)\n  // Instead, we wait until the commit phase to attach our handler.\n  //\n  // We intentionally use a passive effect (useEffect) rather than a synchronous one (useLayoutEffect)\n  // so that we don't stretch the commit phase.\n  // This also has an added benefit when multiple components are subscribed to the same source:\n  // It allows each of the event handlers to safely schedule work without potentially removing an another handler.\n  // (Learn more at https://codesandbox.io/s/k0yvr5970o)\n  useEffect(() => {\n    let didUnsubscribe = false;\n\n    const checkForUpdates = () => {\n      // It's possible that this callback will be invoked even after being unsubscribed,\n      // if it's removed as a result of a subscription event/update.\n      // In this case, React will log a DEV warning about an update from an unmounted component.\n      // We can avoid triggering that warning with this check.\n      if (didUnsubscribe) {\n        return;\n      }\n\n      setState(prevState => {\n        // Ignore values from stale sources!\n        // Since we subscribe an unsubscribe in a passive effect,\n        // it's possible that this callback will be invoked for a stale (previous) subscription.\n        // This check avoids scheduling an update for that stale subscription.\n        if (\n          prevState.getCurrentValue !== getCurrentValue ||\n          prevState.subscribe !== subscribe\n        ) {\n          return prevState;\n        }\n\n        // Some subscriptions will auto-invoke the handler, even if the value hasn't changed.\n        // If the value hasn't changed, no update is needed.\n        // Return state as-is so React can bail out and avoid an unnecessary render.\n        const value = getCurrentValue();\n        if (prevState.value === value) {\n          return prevState;\n        }\n\n        return { ...prevState, value };\n      });\n    };\n    const unsubscribe = subscribe(checkForUpdates);\n\n    // Because we're subscribing in a passive effect,\n    // it's possible that an update has occurred between render and our effect handler.\n    // Check for this and schedule an update if work has occurred.\n    checkForUpdates();\n\n    return () => {\n      didUnsubscribe = true;\n      unsubscribe();\n    };\n  }, [getCurrentValue, subscribe]);\n\n  // Return the current value for our caller to use while rendering.\n  return valueToReturn;\n}\n", "import { useMemo, useState } from \"react\";\n\nimport { GenericAPI, NamedQuery } from \"../api/index.js\";\nimport { OptimisticLocalStore } from \"../browser/index.js\";\nimport { PaginationOptions, PaginationResult } from \"../server/index.js\";\nimport { PickByValue } from \"../type_utils.js\";\nimport { convexToJson, Value } from \"../values/index.js\";\nimport { RequestForQueries, useQueriesGeneric } from \"./use_queries.js\";\n\n/**\n * Load data reactively from a paginated query to a create a growing list.\n *\n * This can be used to power \"infinite scroll\" UIs.\n *\n * This hook must be used with Convex query functions that match\n * {@link PaginatedQueryFunction}. This means they must:\n * 1. Have a first argument must be an object containing `numItems` and `cursor`.\n * 2. Return a {@link server.PaginationResult}.\n *\n * `usePaginatedQueryGeneric` concatenates all the pages\n * of results into a single list and manages the continuation cursors when\n * requesting more items.\n *\n * Example usage:\n * ```typescript\n * const { results, status, loadMore } = usePaginatedQueryGeneric(\n *   \"listMessages\",\n *   { initialNumItems: 5 },\n *   \"#general\"\n * );\n * ```\n *\n * If the query `name` or `args` change, the pagination state will be reset\n * to the first page. Similarly, if any of the pages result in an InvalidCursor\n * or QueryScannedTooManyDocuments error, the pagination state will also reset\n * to the first page.\n *\n * To learn more about pagination, see [Paginated Queries](https://docs.convex.dev/using/pagination).\n *\n * If you're using code generation, use the `usePaginatedQuery` function in\n * `convex/_generated/react.js` which is typed for your API.\n *\n * @param name - The name of the query function.\n * @param options - An object specifying the `initialNumItems` to be loaded in\n * the first page.\n * @param args - The arguments to the query function, excluding the first.\n * @returns A {@link UsePaginatedQueryResult} that includes the currently loaded\n * items, the status of the pagination, and a `loadMore` function.\n *\n * @public\n */\nexport function usePaginatedQueryGeneric(\n  name: string,\n  options: { initialNumItems: number },\n  ...args: Value[]\n): UsePaginatedQueryResult<any> {\n  if (\n    typeof options?.initialNumItems !== \"number\" ||\n    options.initialNumItems < 0\n  ) {\n    throw new Error(\n      `\\`options.initialNumItems\\` must be a positive number. Received \\`${options?.initialNumItems}\\`.`\n    );\n  }\n\n  const createInitialState = useMemo(() => {\n    return () => {\n      const id = nextPaginationId();\n      return {\n        name,\n        args,\n        id,\n        maxQueryIndex: 0,\n        queries: {\n          0: {\n            name,\n            args: [\n              {\n                numItems: options.initialNumItems,\n                cursor: null,\n                id,\n              },\n              ...args,\n            ],\n          },\n        },\n      };\n    };\n    // ESLint doesn't like that we're stringifying the args. We do this because\n    // we want to avoid rerendering if the args are a different\n    // object that serializes to the same result.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [JSON.stringify(convexToJson(args)), name, options.initialNumItems]);\n\n  const [state, setState] = useState<{\n    name: string;\n    args: Value[];\n    id: number;\n    maxQueryIndex: number;\n    queries: RequestForQueries;\n  }>(createInitialState);\n\n  // `currState` is the state that we'll render based on.\n  let currState = state;\n  if (\n    name !== state.name ||\n    JSON.stringify(convexToJson(args)) !==\n      JSON.stringify(convexToJson(state.args))\n  ) {\n    currState = createInitialState();\n    setState(currState);\n  }\n\n  const resultsObject = useQueriesGeneric(currState.queries);\n\n  const [results, maybeLastResult]: [\n    Value[],\n    undefined | PaginationResult<Value>\n  ] = useMemo(() => {\n    let currResult = undefined;\n\n    const allItems = [];\n    for (let i = 0; i <= currState.maxQueryIndex; i++) {\n      currResult = resultsObject[i];\n      if (currResult === undefined) {\n        break;\n      }\n\n      if (currResult instanceof Error) {\n        if (\n          currResult.message.includes(\"InvalidCursor\") ||\n          currResult.message.includes(\"QueryScannedTooManyDocuments\")\n        ) {\n          // `useInifinteQuery` handles a few types of query errors:\n\n          // 1. InvalidCursor: If the cursor is invalid, probably the paginated\n          // database query was data-dependent and changed underneath us. The\n          // cursor in the params or journal no longer matches the current\n          // database query.\n          // 2. QueryScannedTooManyDocuments: Likely so many elements were\n          // added to a single page they hit our limit.\n\n          // In both cases we want to restart pagination to throw away all our\n          // existing cursors.\n          setState(createInitialState);\n          return [[], undefined];\n        } else {\n          throw currResult;\n        }\n      }\n      allItems.push(...currResult.page);\n    }\n    return [allItems, currResult];\n  }, [resultsObject, currState.maxQueryIndex, createInitialState]);\n\n  const statusAndLoadMore = useMemo(() => {\n    if (maybeLastResult === undefined) {\n      return {\n        status: \"LoadingMore\",\n        loadMore: undefined,\n      } as const;\n    }\n    if (maybeLastResult.isDone) {\n      return {\n        status: \"Exhausted\",\n        loadMore: undefined,\n      } as const;\n    }\n    const continueCursor = maybeLastResult.continueCursor;\n    let alreadyLoadingMore = false;\n    return {\n      status: \"CanLoadMore\",\n      loadMore: (numItems: number) => {\n        if (!alreadyLoadingMore) {\n          alreadyLoadingMore = true;\n          setState(prevState => {\n            const maxQueryIndex = prevState.maxQueryIndex + 1;\n            const queries = { ...prevState.queries };\n            queries[maxQueryIndex] = {\n              name: prevState.name,\n              args: [\n                { numItems, cursor: continueCursor, id: prevState.id },\n                ...prevState.args,\n              ],\n            };\n            return {\n              ...prevState,\n              maxQueryIndex,\n              queries,\n            };\n          });\n        }\n      },\n    } as const;\n  }, [maybeLastResult]);\n\n  return {\n    results,\n    ...statusAndLoadMore,\n  };\n}\n\nlet paginationId = 0;\n/**\n * Generate a new, unique ID for a pagination session.\n *\n * Every usage of {@link usePaginatedQueryGeneric} puts a unique ID into the\n * query function arguments as a \"cache-buster\". This serves two purposes:\n *\n * 1. All calls to {@link usePaginatedQueryGeneric} have independent query\n * journals.\n *\n * Every time we start a new pagination session, we'll load the first page of\n * results and receive a fresh journal. Without the ID, we might instead reuse\n * a query subscription already present in our client. This isn't desirable\n * because the existing query function result may have grown or shrunk from the\n * requested `initialNumItems`.\n *\n * 2. We can restart the pagination session on some types of errors.\n *\n * Sometimes we want to restart pagination from the beginning if we hit an error.\n * Similar to (1), we'd like to ensure that this new session actually requests\n * its first page from the server and doesn't reuse a query result already\n * present in the client that may have hit the error.\n *\n * @returns The pagination ID.\n */\nfunction nextPaginationId(): number {\n  paginationId++;\n  return paginationId;\n}\n\n/**\n * The result of calling the {@link usePaginatedQueryGeneric} hook.\n *\n * This includes:\n * 1. `results` - An array of the currently loaded results.\n * 2. `status` - The status of the pagination. The possible statuses are:\n *   - \"CanLoadMore\": This query may have more items to fetch. Call `loadMore` to\n *   fetch another page.\n *   - \"LoadingMore\": We're currently loading another page of results.\n *   - \"Exhausted\": We've paginated to the end of the list.\n * 3. `loadMore` A callback to fetch more results. This will be `undefined`\n * unless the status is \"CanLoadMore\".\n *\n * @public\n */\nexport type UsePaginatedQueryResult<T> = {\n  results: T[];\n} & (\n  | {\n      status: \"CanLoadMore\";\n      loadMore: (numItems: number) => void;\n    }\n  | {\n      status: \"LoadingMore\";\n      loadMore: undefined;\n    }\n  | {\n      status: \"Exhausted\";\n      loadMore: undefined;\n    }\n);\n\n/**\n * A query function that is usable with {@link usePaginatedQueryGeneric}.\n *\n * The function's first argument must be a {@link server.PaginationOptions} object.\n * The function must return a {@link server.PaginationResult}.\n *\n * @public\n */\nexport type PaginatedQueryFunction<Args extends any[], ReturnType> = (\n  paginationOptions: PaginationOptions,\n  ...args: Args\n) => PaginationResult<ReturnType>;\n\n/**\n * The names of the paginated query functions in a Convex API.\n *\n * These are normal query functions that match {@link PaginatedQueryFunction}.\n *\n * @public\n */\nexport type PaginatedQueryNames<API extends GenericAPI> = keyof PickByValue<\n  API[\"publicQueries\"],\n  PaginatedQueryFunction<any, any>\n> &\n  string;\n\n/**\n * The type of the arguments to a {@link PaginatedQueryFunction}.\n *\n * This type includes all the arguments after the initial\n * {@link server.PaginationOptions} argument.\n *\n * @public\n */\nexport type PaginatedQueryArgs<Query extends PaginatedQueryFunction<any, any>> =\n  Query extends PaginatedQueryFunction<infer Args, any> ? Args : never;\n\n/**\n * The return type of a {@link PaginatedQueryFunction}.\n *\n * This is the type of the inner document or object within the\n * {@link server.PaginationResult} that a paginated query function returns.\n *\n * @public\n */\nexport type PaginatedQueryReturnType<\n  Query extends PaginatedQueryFunction<any, any>\n> = Query extends PaginatedQueryFunction<any, infer ReturnType>\n  ? ReturnType\n  : never;\n\n/**\n * Internal type helper used by Convex code generation.\n *\n * Used to give {@link usePaginatedQueryGeneric} a type specific to your API.\n *\n * @public\n */\nexport type UsePaginatedQueryForAPI<API extends GenericAPI> = <\n  Name extends PaginatedQueryNames<API>\n>(\n  name: Name,\n  options: { initialNumItems: number },\n  ...args: PaginatedQueryArgs<NamedQuery<API, Name>>\n) => UsePaginatedQueryResult<PaginatedQueryReturnType<NamedQuery<API, Name>>>;\n\n/**\n * Optimistically update the values in a paginated list.\n *\n * This optimistic update is designed to be used to update data loaded with\n * {@link usePaginatedQueryGeneric}. It updates the list by applying\n * `updateValue` to each element of the list across all of the loaded pages.\n *\n * This will only apply to queries with a matching names and arguments.\n *\n * Example usage:\n * ```ts\n * const myMutation = useMutation(\"myMutationName\")\n * .withOptimisticUpdate((localStore, mutationArg) => {\n *\n *   // Optimistically update the document with ID `mutationArg`\n *   // to have an additional property.\n *\n *   optimisticallyUpdateValueInPaginatedQuery(\n *     localStore,\n *     \"paginatedQueryName\",\n *     [],\n *     currentValue => {\n *       if (mutationArg.equals(currentValue._id)) {\n *         return {\n *           ...currentValue,\n *           \"newProperty\": \"newValue\",\n *         };\n *       }\n *       return currentValue;\n *     }\n *   );\n *\n * });\n * ```\n *\n * @param name - The name of the paginated query function.\n * @param args - The arguments to the query function, excluding the first.\n * @param updateValue - A function to produce the new values.\n *\n * @public\n */\nexport function optimisticallyUpdateValueInPaginatedQuery<\n  API extends GenericAPI,\n  Name extends PaginatedQueryNames<API>\n>(\n  localStore: OptimisticLocalStore<API>,\n  name: Name,\n  args: PaginatedQueryArgs<NamedQuery<API, Name>>,\n  updateValue: (\n    currentValue: PaginatedQueryReturnType<NamedQuery<API, Name>>\n  ) => PaginatedQueryReturnType<NamedQuery<API, Name>>\n): void {\n  // TODO(CX-749): This should really be sorted JSON or an `equals` method\n  // so that the order of properties in sets, maps, and objects doesn't break\n  // our comparison.\n  const expectedArgs = JSON.stringify(convexToJson(args));\n\n  for (const query of localStore.getAllQueries(name)) {\n    if (\n      query.value !== undefined &&\n      query.args.length >= 1 &&\n      JSON.stringify(convexToJson(query.args.slice(1))) === expectedArgs\n    ) {\n      const value = query.value;\n      if (\n        typeof value === \"object\" &&\n        value !== null &&\n        Array.isArray(value.page)\n      ) {\n        localStore.setQuery(name, query.args, {\n          ...value,\n          page: value.page.map(updateValue),\n        });\n      }\n    }\n  }\n}\n", "import { Value } from \"../values/index.js\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport { useConvexGeneric } from \"./index.js\";\nimport { GenericAPI, NamedQuery, PublicQueryNames } from \"../api/index.js\";\nimport { CreateWatch, QueriesObserver } from \"./queries_observer.js\";\nimport { useSubscription } from \"./use_subscription.js\";\nimport { QueryJournal } from \"../browser/index.js\";\n\n/**\n * Load a variable number of reactive Convex queries.\n *\n * `useQueriesGeneric` is similar to {@link useQueryGeneric} but it allows\n * loading multiple queries which can be useful for loading a dynamic number\n * of queries without violating the rules of React hooks.\n *\n * This hook accepts an object whose keys are identifiers for each query and the\n * values are objects of `{ name: string, args: Value[] }`. The `name` is the\n * name of the Convex query function to load, and the `args` are the arguments to\n * that function.\n *\n * The hook returns an object that maps each identifier to the result of the query,\n * `undefined` if the query is still loading, or an instance of `Error` if the query\n * threw an exception.\n *\n * For example if you loaded a query like:\n * ```typescript\n * const results = useQueriesGeneric({\n *   messagesInGeneral: {\n *     name: \"listMessages\",\n *     args: [\"#general\"]\n *   }\n * });\n * ```\n * then the result would look like:\n * ```typescript\n * {\n *   messagesInGeneral: [{\n *     channel: \"#general\",\n *     body: \"hello\"\n *     _id: ...,\n *     _creationTime: ...\n *   }]\n * }\n * ```\n *\n * This React hook contains internal state that will cause a rerender\n * whenever any of the query results change.\n *\n * Throws an error if not used under {@link ConvexProvider}.\n *\n * If you're using code generation, use the `useQueries` function in\n * `convex/_generated/react.js` which is typed for your API.\n *\n * @param queries - An object mapping identifiers to objects of\n * `{name: string, args: Value[] }` describing which query functions to fetch.\n * @returns An object with the same keys as the input. The values are the result\n * of the query function, `undefined` if it's still loading, or an `Error` if\n * it threw an exception.\n *\n * @public\n */\nexport function useQueriesGeneric(\n  queries: RequestForQueries\n): Record<string, any | undefined | Error> {\n  const convex = useConvexGeneric();\n  if (convex === undefined) {\n    throw new Error(\n      \"Could not find Convex client! `useQueries` must be used in the React component \" +\n        \"tree under `ConvexProvider`. Did you forget it? \" +\n        \"See https://docs.convex.dev/quick-start#set-up-convex-in-your-react-app\"\n    );\n  }\n  const createWatch = useMemo(() => {\n    return (name: string, args: Value[], journal?: QueryJournal) => {\n      return convex.watchQuery(name, args, journal);\n    };\n  }, [convex]);\n  return useQueriesHelper(queries, createWatch);\n}\n\n/**\n * Internal version of `useQueriesGeneric` that is exported for testing.\n */\nexport function useQueriesHelper(\n  queries: RequestForQueries,\n  createWatch: CreateWatch\n): Record<string, any | undefined | Error> {\n  const [observer] = useState(() => new QueriesObserver(createWatch));\n  const [effectRan, setEffectRan] = useState(false);\n\n  if (observer.createWatch !== createWatch) {\n    observer.setCreateWatch(createWatch);\n  }\n\n  // Unsubscribe from all queries on unmount.\n  useEffect(() => {\n    setEffectRan(true);\n    return () => {\n      observer.destroy();\n    };\n  }, [observer]);\n\n  const subscription = useMemo(() => {\n    // Any time the queries change, update our observer.\n    // Correctness notes:\n    // 1. `observer.setQueries` could subscribe us to new queries. They are\n    // cleaned up in `observer.destroy()`, but that may never get called!\n    // React may render a component and then throw it out without running\n    // the effects or their destructors. For satefy, we should only subscribe\n    // if the effects have run and the destructor has been configured.\n    // 2. We're calling this during render so it could happen multiple times!\n    // This is okay though because `setQueries` is written to be idempotent.\n    // 3. When the queries change, we want to immediately return the results of\n    // the new queries. This happens because we recreate the `getCurrentValue`\n    // callback and `useSubscription` re-executes it.\n    if (effectRan) {\n      observer.setQueries(queries);\n    }\n\n    return {\n      getCurrentValue: () => {\n        if (effectRan) {\n          return observer.getCurrentQueries();\n        } else {\n          // If the effect hasn't run yet, our `observer` doesn't have the\n          // current queries. Manually set all the results to `undefined`.\n          // Once the effect runs, we'll rerender and actually pull the results\n          // from the Convex client.\n          const value: Record<string, undefined> = {};\n          for (const identifier in Object.keys(queries)) {\n            value[identifier] = undefined;\n          }\n          return value;\n        }\n      },\n      subscribe: (callback: () => void) => observer.subscribe(callback),\n    };\n  }, [observer, queries, effectRan]);\n\n  return useSubscription(subscription);\n}\n\n/**\n * An object representing a request to load multiple queries.\n *\n * The keys of this object are identifiers and the values are objects containing\n * the name of the query function and the arguments to pass to it.\n *\n * This is used as an argument to {@link useQueriesGeneric}.\n * @public\n */\nexport type RequestForQueries = Record<\n  string,\n  {\n    name: string;\n    args: Value[];\n  }\n>;\n\n/**\n * Internal type helper used by Convex code generation.\n *\n * Used to give {@link useQueriesGeneric} a type specific to your API.\n *\n * @public\n */\nexport type UseQueriesForAPI<API extends GenericAPI> = <\n  QueryNameMap extends Record<string, PublicQueryNames<API>>\n>(queries: {\n  [Identifier in keyof QueryNameMap]: {\n    name: QueryNameMap[Identifier];\n    args: Parameters<NamedQuery<API, QueryNameMap[Identifier]>>;\n  };\n}) => {\n  [Identifier in keyof QueryNameMap]:\n    | ReturnType<NamedQuery<API, QueryNameMap[Identifier]>>\n    | undefined\n    | Error;\n};\n", "import { convexToJson, Value } from \"../values/index.js\";\nimport { Watch } from \".\";\nimport { QueryJournal } from \"../browser/sync/protocol.js\";\n\ntype Identifier = string;\n\ntype QueryInfo = {\n  name: string;\n  args: Value[];\n  watch: Watch<Value>;\n  unsubscribe: () => void;\n};\n\nexport type CreateWatch = (\n  name: string,\n  args: Value[],\n  journal?: QueryJournal\n) => Watch<Value>;\n\n/**\n * A class for observing the results of multiple queries at the same time.\n *\n * Any time the result of a query changes, the listeners are notified.\n */\nexport class QueriesObserver {\n  public createWatch: CreateWatch;\n  private queries: Record<Identifier, QueryInfo>;\n  private listeners: Set<() => void>;\n\n  constructor(createWatch: CreateWatch) {\n    this.createWatch = createWatch;\n    this.queries = {};\n    this.listeners = new Set();\n  }\n\n  setQueries(newQueries: Record<Identifier, { name: string; args: Value[] }>) {\n    // Add the new queries before unsubscribing from the old ones so that\n    // the deduping in the `ConvexReactClient` can help if there are duplicates.\n    for (const identifier of Object.keys(newQueries)) {\n      const { name, args } = newQueries[identifier];\n\n      if (this.queries[identifier] === undefined) {\n        // No existing query => add it.\n        this.addQuery(identifier, name, args);\n      } else {\n        const existingInfo = this.queries[identifier];\n        if (\n          name !== existingInfo.name ||\n          JSON.stringify(convexToJson(args)) !==\n            JSON.stringify(convexToJson(existingInfo.args))\n        ) {\n          // Existing query that doesn't match => remove the old and add the new.\n          this.removeQuery(identifier);\n          this.addQuery(identifier, name, args);\n        }\n      }\n    }\n\n    // Prune all the existing queries that we no longer need.\n    for (const identifier of Object.keys(this.queries)) {\n      if (newQueries[identifier] === undefined) {\n        this.removeQuery(identifier);\n      }\n    }\n  }\n\n  subscribe(listener: () => void): () => void {\n    this.listeners.add(listener);\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  getCurrentQueries(): Record<Identifier, Value | undefined | Error> {\n    const result: Record<Identifier, Value | Error | undefined> = {};\n    for (const identifier of Object.keys(this.queries)) {\n      let value: Value | undefined | Error;\n      try {\n        value = this.queries[identifier].watch.localQueryResult();\n      } catch (e) {\n        // Only collect instances of `Error` because thats how callers\n        // will distinguish errors from normal results.\n        if (e instanceof Error) {\n          value = e;\n        } else {\n          throw e;\n        }\n      }\n      result[identifier] = value;\n    }\n    return result;\n  }\n\n  setCreateWatch(createWatch: CreateWatch) {\n    this.createWatch = createWatch;\n    // If we have a new watch, we might be using a new Convex client.\n    // Recreate all the watches being careful to preserve the journals.\n    for (const identifier of Object.keys(this.queries)) {\n      const { name, args, watch } = this.queries[identifier];\n      const journal = watch.journal();\n      this.removeQuery(identifier);\n      this.addQuery(identifier, name, args, journal);\n    }\n  }\n\n  destroy() {\n    for (const identifier of Object.keys(this.queries)) {\n      this.removeQuery(identifier);\n    }\n    this.listeners = new Set();\n  }\n\n  private addQuery(\n    identifier: Identifier,\n    name: string,\n    args: Value[],\n    journal?: QueryJournal\n  ) {\n    if (this.queries[identifier] !== undefined) {\n      throw new Error(\n        `Tried to add a new query with identifier ${identifier} when it already exists.`\n      );\n    }\n    const watch = this.createWatch(name, args, journal);\n    const unsubscribe = watch.onUpdate(() => this.notifyListeners());\n    this.queries[identifier] = {\n      name,\n      args,\n      watch,\n      unsubscribe,\n    };\n  }\n\n  private removeQuery(identifier: Identifier) {\n    const info = this.queries[identifier];\n    if (info === undefined) {\n      throw new Error(`No query found with identifier ${identifier}.`);\n    }\n    info.unsubscribe();\n    delete this.queries[identifier];\n  }\n\n  private notifyListeners(): void {\n    for (const listener of this.listeners) {\n      listener();\n    }\n  }\n}\n", "import { GenericAPI, MutationNames } from \"../browser/index.js\";\nimport { StorageId } from \"../server/storage.js\";\nimport { useMutationGeneric } from \"../react/index.js\";\n\n/**\n * TODO(CX-2960) Use codegen to make non-generic version\n *\n * @internal\n */\nexport function useUploadGeneric<\n  API extends GenericAPI,\n  Name extends MutationNames<API>\n>(name: Name): (file: File) => Promise<StorageId> {\n  const generateUploadUrl = useMutationGeneric(name);\n\n  return async (file: File): Promise<StorageId> => {\n    const postUrl = await generateUploadUrl();\n    const res = await fetch(postUrl, {\n      method: \"POST\",\n      headers: { \"Content-Type\": file.type },\n      body: file,\n    });\n    if (res.status === 200) {\n      const { storageId } = await res.json();\n      return storageId;\n    } else {\n      const { code, message } = await res.json();\n      console.error(`${res.status} ${res.statusText}: ${code}: ${message}`);\n      throw new Error(`${res.status} ${res.statusText}: ${code}: ${message}`);\n    }\n  };\n}\n", "import React, {\n  createContext,\n  ReactNode,\n  useContext,\n  useEffect,\n  useState,\n} from \"react\";\nimport { AuthTokenFetcher, ConvexProvider } from \"../react/index.js\";\n\n// Until we can import from our own entry points (requires TypeScript 4.7),\n// just describe the interface enough to help users pass the right type.\ntype IConvexReactClient = {\n  setAuth(fetchToken: AuthTokenFetcher): Promise<void>;\n  clearAuth(): void;\n};\n\n/**\n * Type representing the state of an auth integration with Convex.\n *\n * @public\n */\nexport type ConvexAuthState = {\n  isLoading: boolean;\n  isAuthenticated: boolean;\n};\n\nconst ConvexAuthContext = createContext<ConvexAuthState>(undefined as any);\n\n/**\n * Get the {@link ConvexAuthState} within a React component.\n *\n * This relies on a Convex auth integration provider being above in the React\n * component tree.\n *\n * @returns The current {@link ConvexAuthState}.\n *\n * @public\n */\nexport function useConvexAuth(): {\n  isLoading: boolean;\n  isAuthenticated: boolean;\n} {\n  return useContext(ConvexAuthContext);\n}\n\n/**\n * A replacement for {@link ConvexProvider} which additionally provides\n * {@link ConvexAuthState} to descendants of this component.\n *\n * Use this to integrate any auth provider with Convex. The `useAuth` prop\n * should be a React hook that returns the provider's authentication state\n * and a function to fetch a JWT access token.\n *\n * See [Custom Auth Integration](https://docs.convex.dev/auth/custom-auth) for more information.\n *\n * @public\n */\nexport function ConvexProviderWithAuth({\n  children,\n  client,\n  useAuth,\n}: {\n  children?: ReactNode;\n  client: IConvexReactClient;\n  useAuth: () => {\n    isLoading: boolean;\n    isAuthenticated: boolean;\n    fetchAccessToken: () => Promise<string | null>;\n  };\n}) {\n  const { isLoading, isAuthenticated, fetchAccessToken } = useAuth();\n  const [isConvexAuthenticated, setIsConvexAuthenticated] = useState<\n    boolean | null\n  >(null);\n\n  useEffect(() => {\n    let isThisEffectRelevant = true;\n\n    async function setToken() {\n      await client.setAuth(fetchAccessToken);\n      if (isThisEffectRelevant) {\n        setIsConvexAuthenticated(true);\n      }\n    }\n\n    if (isAuthenticated) {\n      void setToken();\n      return () => {\n        isThisEffectRelevant = false;\n\n        // If we haven't finished fetching the token by now\n        // we shouldn't transition to a loaded state\n        setIsConvexAuthenticated(isConvexAuthenticated =>\n          isConvexAuthenticated ? false : null\n        );\n        client.clearAuth();\n      };\n    }\n  }, [isAuthenticated, fetchAccessToken, isLoading, client]);\n\n  // If the useAuth went back to loading state (which is unusual but possible)\n  // reset the Convex auth state to null so that we can correctly\n  // transition from loading straight to authenticated state\n  // without going through unauthenticated state.\n  if (isLoading && isConvexAuthenticated !== null) {\n    setIsConvexAuthenticated(null);\n  }\n\n  if (!isLoading && !isAuthenticated && isConvexAuthenticated !== false) {\n    setIsConvexAuthenticated(false);\n  }\n\n  return (\n    <ConvexAuthContext.Provider\n      value={{\n        isLoading: isConvexAuthenticated === null,\n        isAuthenticated: isAuthenticated && (isConvexAuthenticated ?? false),\n      }}\n    >\n      <ConvexProvider client={client as any}>{children}</ConvexProvider>\n    </ConvexAuthContext.Provider>\n  );\n}\n", "import { ReactNode } from \"react\";\nimport { useConvexAuth } from \"./ConvexAuthState.js\";\n\n/**\n * Renders children if the client is authenticated.\n *\n * @public\n */\nexport function Authenticated({ children }: { children: ReactNode }) {\n  const { isLoading, isAuthenticated } = useConvexAuth();\n  if (isLoading || !isAuthenticated) {\n    return null;\n  }\n  return children;\n}\n\n/**\n * Renders children if the client is using authentication but is not authenticated.\n *\n * @public\n */\nexport function Unauthenticated({ children }: { children: ReactNode }) {\n  const { isLoading, isAuthenticated } = useConvexAuth();\n  if (isLoading || isAuthenticated) {\n    return null;\n  }\n  return children;\n}\n\n/**\n * Renders children if the client isn't using authentication or is in the process\n * of authenticating.\n *\n * @public\n */\nexport function AuthLoading({ children }: { children: ReactNode }) {\n  const { isLoading } = useConvexAuth();\n  if (!isLoading) {\n    return null;\n  }\n  return children;\n}\n"],
  "mappings": ";;;;;;;;;;;;AAAA;AAAA;AAAA;AAEA,YAAQ,aAAa;AACrB,YAAQ,cAAcA;AACtB,YAAQ,gBAAgBC;AAExB,QAAI,SAAS,CAAC;AACd,QAAI,YAAY,CAAC;AACjB,QAAI,MAAM,OAAO,eAAe,cAAc,aAAa;AAE3D,QAAI,OAAO;AACX,SAAS,IAAI,GAAG,MAAM,KAAK,QAAQ,IAAI,KAAK,EAAE,GAAG;AAC/C,aAAO,CAAC,IAAI,KAAK,CAAC;AAClB,gBAAU,KAAK,WAAW,CAAC,CAAC,IAAI;AAAA,IAClC;AAHS;AAAO;AAOhB,cAAU,IAAI,WAAW,CAAC,CAAC,IAAI;AAC/B,cAAU,IAAI,WAAW,CAAC,CAAC,IAAI;AAE/B,aAAS,QAAS,KAAK;AACrB,UAAIC,OAAM,IAAI;AAEd,UAAIA,OAAM,IAAI,GAAG;AACf,cAAM,IAAI,MAAM,gDAAgD;AAAA,MAClE;AAIA,UAAI,WAAW,IAAI,QAAQ,GAAG;AAC9B,UAAI,aAAa;AAAI,mBAAWA;AAEhC,UAAI,kBAAkB,aAAaA,OAC/B,IACA,IAAK,WAAW;AAEpB,aAAO,CAAC,UAAU,eAAe;AAAA,IACnC;AAGA,aAAS,WAAY,KAAK;AACxB,UAAI,OAAO,QAAQ,GAAG;AACtB,UAAI,WAAW,KAAK,CAAC;AACrB,UAAI,kBAAkB,KAAK,CAAC;AAC5B,cAAS,WAAW,mBAAmB,IAAI,IAAK;AAAA,IAClD;AAEA,aAAS,YAAa,KAAK,UAAU,iBAAiB;AACpD,cAAS,WAAW,mBAAmB,IAAI,IAAK;AAAA,IAClD;AAEA,aAASF,aAAa,KAAK;AACzB,UAAI;AACJ,UAAI,OAAO,QAAQ,GAAG;AACtB,UAAI,WAAW,KAAK,CAAC;AACrB,UAAI,kBAAkB,KAAK,CAAC;AAE5B,UAAI,MAAM,IAAI,IAAI,YAAY,KAAK,UAAU,eAAe,CAAC;AAE7D,UAAI,UAAU;AAGd,UAAIE,OAAM,kBAAkB,IACxB,WAAW,IACX;AAEJ,UAAIC;AACJ,WAAKA,KAAI,GAAGA,KAAID,MAAKC,MAAK,GAAG;AAC3B,cACG,UAAU,IAAI,WAAWA,EAAC,CAAC,KAAK,KAChC,UAAU,IAAI,WAAWA,KAAI,CAAC,CAAC,KAAK,KACpC,UAAU,IAAI,WAAWA,KAAI,CAAC,CAAC,KAAK,IACrC,UAAU,IAAI,WAAWA,KAAI,CAAC,CAAC;AACjC,YAAI,SAAS,IAAK,OAAO,KAAM;AAC/B,YAAI,SAAS,IAAK,OAAO,IAAK;AAC9B,YAAI,SAAS,IAAI,MAAM;AAAA,MACzB;AAEA,UAAI,oBAAoB,GAAG;AACzB,cACG,UAAU,IAAI,WAAWA,EAAC,CAAC,KAAK,IAChC,UAAU,IAAI,WAAWA,KAAI,CAAC,CAAC,KAAK;AACvC,YAAI,SAAS,IAAI,MAAM;AAAA,MACzB;AAEA,UAAI,oBAAoB,GAAG;AACzB,cACG,UAAU,IAAI,WAAWA,EAAC,CAAC,KAAK,KAChC,UAAU,IAAI,WAAWA,KAAI,CAAC,CAAC,KAAK,IACpC,UAAU,IAAI,WAAWA,KAAI,CAAC,CAAC,KAAK;AACvC,YAAI,SAAS,IAAK,OAAO,IAAK;AAC9B,YAAI,SAAS,IAAI,MAAM;AAAA,MACzB;AAEA,aAAO;AAAA,IACT;AAEA,aAAS,gBAAiB,KAAK;AAC7B,aAAO,OAAO,OAAO,KAAK,EAAI,IAC5B,OAAO,OAAO,KAAK,EAAI,IACvB,OAAO,OAAO,IAAI,EAAI,IACtB,OAAO,MAAM,EAAI;AAAA,IACrB;AAEA,aAAS,YAAa,OAAO,OAAO,KAAK;AACvC,UAAI;AACJ,UAAI,SAAS,CAAC;AACd,eAASA,KAAI,OAAOA,KAAI,KAAKA,MAAK,GAAG;AACnC,eACI,MAAMA,EAAC,KAAK,KAAM,aAClB,MAAMA,KAAI,CAAC,KAAK,IAAK,UACtB,MAAMA,KAAI,CAAC,IAAI;AAClB,eAAO,KAAK,gBAAgB,GAAG,CAAC;AAAA,MAClC;AACA,aAAO,OAAO,KAAK,EAAE;AAAA,IACvB;AAEA,aAASF,eAAe,OAAO;AAC7B,UAAI;AACJ,UAAIC,OAAM,MAAM;AAChB,UAAI,aAAaA,OAAM;AACvB,UAAI,QAAQ,CAAC;AACb,UAAI,iBAAiB;AAGrB,eAASC,KAAI,GAAGC,QAAOF,OAAM,YAAYC,KAAIC,OAAMD,MAAK,gBAAgB;AACtE,cAAM,KAAK,YAAY,OAAOA,IAAIA,KAAI,iBAAkBC,QAAOA,QAAQD,KAAI,cAAe,CAAC;AAAA,MAC7F;AAGA,UAAI,eAAe,GAAG;AACpB,cAAM,MAAMD,OAAM,CAAC;AACnB,cAAM;AAAA,UACJ,OAAO,OAAO,CAAC,IACf,OAAQ,OAAO,IAAK,EAAI,IACxB;AAAA,QACF;AAAA,MACF,WAAW,eAAe,GAAG;AAC3B,eAAO,MAAMA,OAAM,CAAC,KAAK,KAAK,MAAMA,OAAM,CAAC;AAC3C,cAAM;AAAA,UACJ,OAAO,OAAO,EAAE,IAChB,OAAQ,OAAO,IAAK,EAAI,IACxB,OAAQ,OAAO,IAAK,EAAI,IACxB;AAAA,QACF;AAAA,MACF;AAEA,aAAO,MAAM,KAAK,EAAE;AAAA,IACtB;AAAA;AAAA;;;ACrJO,IAAM,UAAU;;;ACOvB,aAAwB;AAExB,IAAM,gBAAgB;AAEtB,IAAM,YAAY,OAAO,sBAAsB;AAC/C,IAAM,YAAY,OAAO,qBAAqB;AAC9C,IAAM,OAAO,OAAO,GAAG;AACvB,IAAM,QAAQ,OAAO,GAAG;AACxB,IAAM,cAAc,OAAO,KAAK;AAuCzB,IAAM,KAAN,MAAmC;EAaxC,YAAY,WAAsB,IAAY;AAC5C,SAAK,YAAY;AACjB,SAAK,KAAK;EACZ;EAQA,OAAO,OAAyB;AAC9B,QAAI,iBAAiB,IAAI;AACvB,aAAO,KAAK,cAAc,MAAM,aAAa,KAAK,OAAO,MAAM;IACjE;AACA,WAAO;EACT;EAKA,OAAO,SAAS,KAAsB;AACpC,QAAI,OAAO,IAAI,QAAQ,UAAU;AAC/B,YAAM,IAAI;QACR,UAAU,KAAK,UAAU,GAAG;MAC9B;IACF;AACA,UAAM,QAAQ,IAAI,IAAI,MAAM,GAAG;AAC/B,QAAI,MAAM,WAAW,GAAG;AACtB,YAAM,IAAI;QACR,UAAU,KAAK,UAAU,GAAG;MAC9B;IACF;AACA,WAAO,IAAI,GAAG,MAAM,CAAA,GAAI,MAAM,CAAA,CAAE;EAClC;EAKA,SAAoB;AAClB,UAAM,WAAW,GAAG,KAAK,aAAa,KAAK;AAC3C,WAAO,EAAE,KAAK,SAAS;EACzB;EAOA,WAAmB;AACjB,WAAO,KAAK;EACd;EAKA,UAAkB;AAChB,WAAO,OAAO,KAAK,gBAAgB,KAAK;EAC1C;AACF;AAgDA,SAAS,UAAU,GAAW;AAC5B,SAAO,OAAO,MAAM,CAAC,KAAK,CAAC,OAAO,SAAS,CAAC,KAAK,OAAO,GAAG,GAAG,EAAE;AAClE;AAEO,SAAS,mBAAmB,OAAuB;AAExD,MAAI,QAAQ,MAAM;AAChB,aAAS,YAAY;EACvB;AACA,MAAI,MAAM,MAAM,SAAS,EAAE;AAC3B,MAAI,IAAI,SAAS,MAAM;AAAG,UAAM,MAAM;AAEtC,QAAM,QAAQ,IAAI,WAAW,IAAI,YAAY,CAAC,CAAC;AAC/C,MAAI,IAAI;AACR,aAAW,WAAW,IAAI,MAAM,OAAO,EAAG,QAAQ,GAAG;AACnD,UAAM,IAAI,CAAC,SAAS,SAAS,EAAE,CAAC,GAAG,GAAG;AACtC,cAAU;EACZ;AACA,SAAc,qBAAc,KAAK;AACnC;AAEO,SAAS,mBAAmB,SAAyB;AAC1D,QAAM,eAAsB,mBAAY,OAAO;AAC/C,MAAI,aAAa,eAAe,GAAG;AACjC,UAAM,IAAI;MACR,YAAY,aAAa;IAC3B;EACF;AACA,MAAI,QAAQ;AACZ,MAAI,QAAQ;AACZ,aAAW,QAAQ,cAAc;AAC/B,aAAS,OAAO,IAAI,IAAI,eAAe;AACvC;EACF;AACA,MAAI,QAAQ,WAAW;AACrB,aAAS,YAAY;EACvB;AACA,SAAO;AACT;AAEO,SAAS,qBAAqB,OAAuB;AAC1D,MAAI,QAAQ,aAAa,YAAY,OAAO;AAC1C,UAAM,IAAI;MACR,UAAU;IACZ;EACF;AACA,QAAM,SAAS,IAAI,YAAY,CAAC;AAChC,MAAI,SAAS,MAAM,EAAE,YAAY,GAAG,OAAO,IAAI;AAC/C,SAAc,qBAAc,IAAI,WAAW,MAAM,CAAC;AACpD;AAEO,SAAS,qBAAqB,SAAyB;AAC5D,QAAM,eAAsB,mBAAY,OAAO;AAC/C,MAAI,aAAa,eAAe,GAAG;AACjC,UAAM,IAAI;MACR,YAAY,aAAa;IAC3B;EACF;AACA,QAAM,eAAe,IAAI,SAAS,aAAa,MAAM;AACrD,SAAO,aAAa,YAAY,GAAG,IAAI;AACzC;AAGO,IAAM,iBAAkB,SAAS,UAAkB,cACtD,uBACA;AACG,IAAM,iBAAkB,SAAS,UAAkB,cACtD,uBACA;AAEJ,IAAM,qBAAqB;AAC3B,IAAM,kBAAkB;AACxB,IAAM,mBAAmB;AAEzB,SAAS,oBAAoB,GAAW;AACtC,MAAI,EAAE,WAAW,GAAG;AAClB,UAAM,IAAI,MAAM,mCAAmC;EACrD;AACA,MAAI,EAAE,SAAS,oBAAoB;AACjC,UAAM,IAAI;MACR,cAAc,uCAAuC;IACvD;EACF;AACA,MAAI,EAAE,WAAW,GAAG,GAAG;AACrB,UAAM,IAAI,MAAM,cAAc,yCAAyC;EACzE;AACA,MAAI,gBAAgB,KAAK,CAAC,GAAG;AAC3B,UAAM,IAAI,MAAM,cAAc,qCAAqC;EACrE;AACA,MAAI,CAAC,iBAAiB,KAAK,CAAC,GAAG;AAC7B,UAAM,IAAI;MACR,cAAc;IAChB;EACF;AACF;AAEA,SAAS,qBAAqB,OAAyB;AACrD,MAAI,UAAU,MAAM;AAClB,WAAO;EACT;AACA,MAAI,OAAO,UAAU,WAAW;AAC9B,WAAO;EACT;AACA,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO;EACT;AACA,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO;EACT;AACA,MAAI,iBAAiB,OAAO;AAC1B,WAAO,MAAM,IAAI,oBAAoB;EACvC;AACA,MAAI,OAAO,UAAU,UAAU;AAC7B,UAAM,IAAI,MAAM,sBAAsB,OAAO;EAC/C;AACA,QAAM,UAAU,OAAO,QAAQ,KAAK;AACpC,MAAI,QAAQ,WAAW,GAAG;AACxB,UAAM,MAAM,QAAQ,CAAA,EAAG,CAAA;AACvB,QAAI,QAAQ,SAAS,QAAQ,cAAc,QAAQ,cAAc;AAC/D,aAAO,GAAG,SAAS,KAAK;IAC1B;AACA,QAAI,QAAQ,UAAU;AACpB,UAAI,OAAO,MAAM,WAAW,UAAU;AACpC,cAAM,IAAI,MAAM,6BAA6B,OAAO;MACtD;AACA,aAAc,mBAAY,MAAM,MAAM,EAAE;IAC1C;AACA,QAAI,QAAQ,YAAY;AACtB,UAAI,OAAO,MAAM,aAAa,UAAU;AACtC,cAAM,IAAI,MAAM,+BAA+B,OAAO;MACxD;AACA,aAAO,eAAe,MAAM,QAAQ;IACtC;AACA,QAAI,QAAQ,UAAU;AACpB,UAAI,OAAO,MAAM,WAAW,UAAU;AACpC,cAAM,IAAI,MAAM,6BAA6B,OAAO;MACtD;AACA,YAAM,aAAoB,mBAAY,MAAM,MAAM;AAClD,UAAI,WAAW,eAAe,GAAG;AAC/B,cAAM,IAAI;UACR,YAAY,WAAW;QACzB;MACF;AACA,YAAM,iBAAiB,IAAI,SAAS,WAAW,MAAM;AACrD,YAAM,QAAQ,eAAe,WAAW,GAAG,aAAa;AACxD,UAAI,CAAC,UAAU,KAAK,GAAG;AACrB,cAAM,IAAI,MAAM,SAAS,qCAAqC;MAChE;AACA,aAAO;IACT;AACA,QAAI,QAAQ,QAAQ;AAClB,UAAI,EAAE,MAAM,gBAAgB,QAAQ;AAClC,cAAM,IAAI,MAAM,2BAA2B,OAAO;MACpD;AACA,aAAO,IAAI,IAAI,MAAM,KAAK,IAAI,oBAAoB,CAAC;IACrD;AACA,QAAI,QAAQ,QAAQ;AAClB,UAAI,EAAE,MAAM,gBAAgB,QAAQ;AAClC,cAAM,IAAI,MAAM,2BAA2B,OAAO;MACpD;AACA,YAAM,MAAM,oBAAI,IAAI;AACpB,iBAAW,QAAQ,MAAM,MAAM;AAC7B,YAAI,EAAE,gBAAgB,UAAU,KAAK,WAAW,GAAG;AACjD,gBAAM,IAAI,MAAM,0BAA0B,OAAO;QACnD;AACA,cAAM,IAAI,qBAAqB,KAAK,CAAA,CAAE;AACtC,cAAM,IAAI,qBAAqB,KAAK,CAAA,CAAE;AACtC,YAAI,IAAI,GAAG,CAAC;MACd;AACA,aAAO;IACT;EACF;AACA,QAAM,MAAgC,CAAC;AACvC,aAAW,CAAC,GAAG,CAAC,KAAK,OAAO,QAAQ,KAAK,GAAG;AAC1C,wBAAoB,CAAC;AACrB,QAAI,CAAA,IAAK,qBAAqB,CAAC;EACjC;AACA,SAAO;AACT;AAcO,SAAS,aAAa,OAAyB;AACpD,SAAO,qBAAqB,KAAK;AACnC;AAEA,SAAS,uBAAuB,OAAY;AAC1C,SAAO,KAAK,UAAU,OAAO,CAAC,MAAMG,WAAU;AAC5C,QAAIA,WAAU,QAAW;AAKvB,aAAO;IACT;AACA,WAAOA;EACT,CAAC;AACH;AAEA,SAAS,qBACP,OACA,eACA,SACW;;AACX,MAAI,UAAU,QAAW;AACvB,UAAM,cACJ,WACA,qBAAqB,8BAA8B;MACjD;IACF;AACF,UAAM,IAAI;MACR,wCAAwC;IAC1C;EACF;AACA,MAAI,UAAU,MAAM;AAClB,WAAO;EACT;AACA,MAAI,iBAAiB,IAAI;AACvB,WAAO,MAAM,OAAO;EACtB;AACA,MAAI,OAAO,UAAU,UAAU;AAC7B,QAAI,QAAQ,aAAa,YAAY,OAAO;AAC1C,YAAM,IAAI;QACR,UAAU;MACZ;IACF;AACA,WAAO,EAAE,UAAU,eAAe,KAAK,EAAE;EAC3C;AACA,MAAI,OAAO,UAAU,UAAU;AAC7B,QAAI,UAAU,KAAK,GAAG;AACpB,YAAM,SAAS,IAAI,YAAY,CAAC;AAChC,UAAI,SAAS,MAAM,EAAE,WAAW,GAAG,OAAO,aAAa;AACvD,aAAO,EAAE,QAAe,qBAAc,IAAI,WAAW,MAAM,CAAC,EAAE;IAChE,OAAO;AACL,aAAO;IACT;EACF;AACA,MAAI,OAAO,UAAU,WAAW;AAC9B,WAAO;EACT;AACA,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO;EACT;AACA,MAAI,iBAAiB,aAAa;AAChC,WAAO,EAAE,QAAe,qBAAc,IAAI,WAAW,KAAK,CAAC,EAAE;EAC/D;AACA,MAAI,iBAAiB,OAAO;AAC1B,WAAO,MAAM;MAAI,CAACA,QAAO,MACvB,qBAAqBA,QAAO,eAAe,UAAU,IAAI,IAAI;IAC/D;EACF;AACA,MAAI,iBAAiB,KAAK;AACxB,WAAO;MACL,MAAM,CAAC,GAAG,KAAK,EAAE;QAAI,CAACA,QAAO,MAC3B,qBAAqBA,QAAO,eAAe,UAAU,WAAW,IAAI;MACtE;IACF;EACF;AACA,MAAI,iBAAiB,KAAK;AACxB,WAAO;MACL,MAAM,CAAC,GAAG,KAAK,EAAE,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,MAAM;AAClC,cAAM,UAAU;UACd;UACA;UACA,UAAU,WAAW;QACvB;AACA,cAAM,YAAY;UAChB;UACA;UACA,UAAU,aAAa;QACzB;AACA,eAAO,CAAC,SAAS,SAAS;MAC5B,CAAC;IACH;EACF;AAEA,QAAM,WAAW,OAAO,UAAU;AAClC,QAAM,YAAY,OAAO,eAAe,KAAK;AAC7C,QAAM,WAAW,cAAc,QAAQ,cAAc,OAAO;AAC5D,MAAI,CAAC,YAAY,CAAC,UAAU;AAC1B,UAAM,WAAU,oCAAO,gBAAP,mBAAoB;AACpC,UAAM,UAAU,UAAU,GAAG,aAAa;AAC1C,QAAI,SAAS;AACX,YAAM,IAAI;QACR,GAAG,UAAU;UACX;QACF,qDAAqD,8BAA8B;UACjF;QACF;MACF;IACF,OAAO;AACL,YAAM,IAAI;QACR,GAAG,UAAU;UACX;QACF;MACF;IACF;EACF;AAEA,QAAM,MAAoC,CAAC;AAC3C,aAAW,CAAC,GAAG,CAAC,KAAK,OAAO,QAAQ,KAAK,GAAG;AAC1C,QAAI,MAAM,QAAW;AACnB,0BAAoB,CAAC;AACrB,UAAI,CAAA,IAAK,qBAAqB,GAAG,eAAe,UAAU,IAAI,GAAG;IACnE;EACF;AACA,SAAO;AACT;AAcO,SAAS,aAAa,OAAyB;AACpD,SAAO,qBAAqB,OAAO,OAAO,EAAE;AAC9C;;;ACzfA,IAAM,aAAa;AAInB,SAAS,kBAAkB,QAAiB;AAC1C,UAAQ,QAAQ;IACd,KAAK;AACH,aAAO;IACT,KAAK;AACH,aAAO;IACT,KAAK;AACH,aAAO;EACX;AACF;AAEO,SAAS,aACd,MACA,QACA,SACA,SACA;AACA,QAAM,SAAS,kBAAkB,MAAM;AACvC,MAAI,SAAS,QAAQ;AACnB,YAAQ,IAAI,aAAa,UAAU,aAAa,WAAW,UAAU;EACvE,OAAO;AACL,YAAQ,MAAM,WAAW,UAAU,aAAa,SAAS;EAC3D;AACF;AAEO,SAAS,cAAc,SAAwB;AACpD,QAAM,eAAe,wBAAwB;AAC7C,UAAQ,MAAM,YAAY;AAC1B,SAAO,IAAI,MAAM,YAAY;AAC/B;AAEO,SAAS,YACd,QACA,SACA,SACO;AACP,QAAM,SAAS,kBAAkB,MAAM;AACvC,SAAO,IAAI,MAAM,WAAW,UAAU,aAAa,SAAS;AAC9D;;;AC1CO,SAAS,oBAAoB,SAAyB;AAC3D,QAAM,SAAS,QAAQ,MAAM,GAAG;AAChC,MAAI;AACJ,MAAI;AACJ,MAAI,OAAO,WAAW,GAAG;AACvB,iBAAa,OAAO,CAAA;AACpB,mBAAe;EACjB,OAAO;AACL,iBAAa,OAAO,MAAM,GAAG,OAAO,SAAS,CAAC,EAAE,KAAK,GAAG;AACxD,mBAAe,OAAO,OAAO,SAAS,CAAA;EACxC;AACA,MAAI,CAAC,WAAW,SAAS,KAAK,GAAG;AAC/B,iBAAa,GAAG;EAClB;AACA,SAAO,GAAG,cAAc;AAC1B;AAYO,SAAS,qBAAqB,SAAiB,MAAyB;AAC7E,SAAO,KAAK,UAAU;IACpB,SAAS,oBAAoB,OAAO;IACpC,MAAM,aAAa,IAAI;EACzB,CAAC;AACH;;;ACNO,IAAM,iBAAN,MAAqB;EAY1B,cAAc;AACZ,SAAK,cAAc;AACnB,SAAK,kBAAkB;AACvB,SAAK,kBAAkB;AACvB,SAAK,WAAW,oBAAI,IAAI;AACxB,SAAK,iBAAiB,oBAAI,IAAI;EAChC;EAEA,UACE,SACA,MACA,SAKA;AACA,UAAM,uBAAuB,oBAAoB,OAAO;AACxD,UAAM,aAAa,qBAAqB,sBAAsB,IAAI;AAElE,UAAM,gBAAgB,KAAK,SAAS,IAAI,UAAU;AAElD,QAAI,kBAAkB,QAAW;AAC/B,oBAAc,kBAAkB;AAChC,aAAO;QACL;QACA,cAAc;QACd,aAAa,MAAM,KAAK,iBAAiB,UAAU;MACrD;IACF,OAAO;AACL,YAAM,UAAU,KAAK;AACrB,YAAM,QAAoB;QACxB,IAAI;QACJ;QACA;QACA,gBAAgB;QAChB;MACF;AACA,WAAK,SAAS,IAAI,YAAY,KAAK;AACnC,WAAK,eAAe,IAAI,SAAS,UAAU;AAE3C,YAAM,cAAc,KAAK;AACzB,YAAM,aAAa,EAAE,KAAK;AAE1B,YAAM,MAAgB;QACpB,MAAM;QACN;QACA,SAAS;QACT,MAAM,KAAK,IAAI,YAAY;QAC3B;MACF;AACA,YAAM,eAAqC;QACzC,MAAM;QACN;QACA;QACA,eAAe,CAAC,GAAG;MACrB;AACA,aAAO;QACL;QACA;QACA,aAAa,MAAM,KAAK,iBAAiB,UAAU;MACrD;IACF;EACF;EAEA,kBAAkB,YAAwB;AACxC,eAAW,gBAAgB,WAAW,eAAe;AACnD,cAAQ,aAAa,MAAM;QACzB,KAAK;QACL,KAAK,eAAe;AAClB,gBAAM,UAAU,aAAa;AAC7B,cAAI,YAAY,QAAW;AACzB,kBAAM,aAAa,KAAK,eAAe,IAAI,aAAa,OAAO;AAG/D,gBAAI,eAAe,QAAW;AAC5B,mBAAK,SAAS,IAAI,UAAU,EAAG,UAAU;YAC3C;UACF;AAEA;QACF;QACA,KAAK,gBAAgB;AACnB;QACF;QACA,SAAS;AAEP,gBAAM,IAAW;AACjB,gBAAM,IAAI,MAAM,wBAAwB,cAAc;QACxD;MACF;IACF;EACF;EAEA,QAAQ,SAAiB,MAA6B;AACpD,UAAM,uBAAuB,oBAAoB,OAAO;AACxD,UAAM,aAAa,qBAAqB,sBAAsB,IAAI;AAClE,UAAM,gBAAgB,KAAK,SAAS,IAAI,UAAU;AAClD,QAAI,kBAAkB,QAAW;AAC/B,aAAO,cAAc;IACvB;AACA,WAAO;EACT;EAEA,QAAQ,OAA6B;AACnC,SAAK,OAAO;MACV,WAAW;MACX;IACF;AACA,UAAM,cAAc,KAAK;AACzB,WAAO;MACL,MAAM;MACN;MACA,GAAG,KAAK;IACV;EACF;EAEA,aACE,OACA,UACqB;AACrB,UAAM,OAEF;MACF,WAAW;MACX;MACA,eAAe;IACjB;AACA,SAAK,OAAO;AACZ,UAAM,cAAc,KAAK;AACzB,WAAO;MACL,MAAM;MACN;MACA,GAAG;IACL;EACF;EAEA,YAA0B;AACxB,SAAK,OAAO;AACZ,UAAM,cAAc,KAAK;AACzB,WAAO;MACL,MAAM;MACN,WAAW;MACX;IACF;EACF;EAEA,UAAmB;AACjB,WAAO,CAAC,CAAC,KAAK;EAChB;EAEA,UAAU,OAAwB;;AAChC,aAAO,UAAK,SAAL,mBAAW,WAAU;EAC9B;EAEA,UAAU,SAAiC;AACzC,UAAM,cAAc,KAAK,eAAe,IAAI,OAAO;AACnD,QAAI,aAAa;AACf,aAAO,KAAK,SAAS,IAAI,WAAW,EAAG;IACzC;AACA,WAAO;EACT;EAEA,UAAU,SAAgC;AACxC,UAAM,cAAc,KAAK,eAAe,IAAI,OAAO;AACnD,QAAI,aAAa;AACf,aAAO,KAAK,SAAS,IAAI,WAAW,EAAG;IACzC;AACA,WAAO;EACT;EAEA,WAAW,SAAiC;AAC1C,WAAO,KAAK,eAAe,IAAI,OAAO,KAAK;EAC7C;EAEA,aAAa,YAAkD;;AAC7D,YAAO,UAAK,SAAS,IAAI,UAAU,MAA5B,mBAA+B;EACxC;EAEA,UAAiD;AAC/C,UAAM,gBAAgB,CAAC;AACvB,eAAW,cAAc,KAAK,SAAS,OAAO,GAAG;AAC/C,YAAM,MAAgB;QACpB,MAAM;QACN,SAAS,WAAW;QACpB,SAAS,WAAW;QACpB,MAAM,WAAW,KAAK,IAAI,YAAY;QACtC,SAAS,WAAW;MACtB;AACA,oBAAc,KAAK,GAAG;IACxB;AACA,SAAK,kBAAkB;AACvB,UAAM,WAAiC;MACrC,MAAM;MACN,aAAa;MACb,YAAY;MACZ;IACF;AAEA,QAAI,CAAC,KAAK,MAAM;AACd,WAAK,kBAAkB;AACvB,aAAO,CAAC,UAAU,MAAS;IAC7B;AACA,UAAM,eAA6B;MACjC,MAAM;MACN,aAAa;MACb,GAAG,KAAK;IACV;AACA,SAAK,kBAAkB;AACvB,WAAO,CAAC,UAAU,YAAY;EAChC;EAEQ,iBACN,YAC6B;AAC7B,UAAM,aAAa,KAAK,SAAS,IAAI,UAAU;AAE/C,QAAI,WAAW,iBAAiB,GAAG;AACjC,iBAAW,kBAAkB;AAC7B,aAAO;IACT,OAAO;AACL,WAAK,SAAS,OAAO,UAAU;AAC/B,WAAK,eAAe,OAAO,WAAW,EAAE;AACxC,YAAM,cAAc,KAAK;AACzB,YAAM,aAAa,EAAE,KAAK;AAC1B,YAAM,SAAsB;QAC1B,MAAM;QACN,SAAS,WAAW;MACtB;AACA,aAAO;QACL,MAAM;QACN;QACA;QACA,eAAe,CAAC,MAAM;MACxB;IACF;EACF;AACF;;;AC7PO,IAAM,iBAAN,MAAqB;EAQ1B,cAAc;AACZ,SAAK,mBAAmB,oBAAI,IAAI;EAClC;EAEA,QACE,SACA,MACc;AACd,UAAM,SAAS,IAAI,QAAQ,CAAC,SAAS,WAAW;AAC9C,YAAM,SAAS,OAAO,cAAc;AACpC,WAAK,iBAAiB,IAAI,QAAQ,WAAW;QAC3C;QACA,QAAQ,EAAE,QAAQ,UAAU,SAAS,WAAW,OAAO;MACzD,CAAC;IACH,CAAC;AAED,WAAO;EACT;EAQA,WAAW,UAA+D;AACxE,UAAM,cAAc,KAAK,iBAAiB,IAAI,SAAS,SAAS;AAChE,QAAI,gBAAgB,QAAW;AAgB7B,aAAO;IACT;AAMA,QAAI,YAAY,OAAO,WAAW,aAAa;AAC7C,aAAO;IACT;AAEA,UAAM,UACJ,YAAY,QAAQ,SAAS,aAAa,aAAa;AACzD,UAAM,UAAU,YAAY,QAAQ;AAEpC,eAAW,QAAQ,SAAS,UAAU;AACpC,mBAAa,QAAQ,SAAS,SAAS,IAAI;IAC7C;AAEA,UAAM,SAAS,YAAY;AAC3B,QAAI;AACJ,QAAI,SAAS,SAAS;AACpB,kBAAY,MAAM,OAAO,SAAS,aAAa,SAAS,MAAM,CAAC;IACjE,OAAO;AACL,mBAAa,SAAS,SAAS,SAAS,SAAS,MAAM;AACvD,kBAAY,MACV,OAAO,UAAU,YAAY,SAAS,SAAS,SAAS,MAAM,CAAC;IACnE;AAMA,QAAI,SAAS,SAAS,oBAAoB,CAAC,SAAS,SAAS;AAC3D,gBAAU;AACV,WAAK,iBAAiB,OAAO,SAAS,SAAS;AAC/C,aAAO,SAAS;IAClB;AAIA,gBAAY,SAAS;MACnB,QAAQ;MACR,IAAI,SAAS;MACb;IACF;AAEA,WAAO;EACT;EAGA,gBAAgB,IAA0B;AACxC,UAAM,mBAAmC,oBAAI,IAAI;AACjD,eAAW,CAAC,WAAW,WAAW,KAAK,KAAK,iBAAiB,QAAQ,GAAG;AACtE,YAAM,SAAS,YAAY;AAC3B,UAAI,OAAO,WAAW,eAAe,OAAO,GAAG,gBAAgB,EAAE,GAAG;AAClE,eAAO,UAAU;AACjB,yBAAiB,IAAI,SAAS;AAC9B,aAAK,iBAAiB,OAAO,SAAS;MACxC;IACF;AACA,WAAO;EACT;EAEA,UAA2B;AAIzB,UAAM,cAAc,CAAC;AACrB,eAAW,CAAC,WAAW,KAAK,KAAK,KAAK,kBAAkB;AACtD,UAAI,MAAM,OAAO,WAAW,WAAW;AACrC,cAAM,OAAO,SAAS;AACtB,oBAAY,KAAK,MAAM,OAAO;AAC9B;MACF;AAEA,UAAI,MAAM,QAAQ,SAAS,YAAY;AAIrC,oBAAY,KAAK,MAAM,OAAO;MAChC,OAAO;AAIL,aAAK,iBAAiB,OAAO,SAAS;AACtC,cAAM,UAAU,MAAM,QAAQ;AAC9B,YAAI,MAAM,OAAO,WAAW,aAAa;AACvC,gBAAM,IAAI,MAAM,6CAA6C;QAC/D;AACA,cAAM,OAAO;UACX,YAAY,UAAU,SAAS,iBAAiB;QAClD;MACF;IACF;AACA,WAAO;EACT;EAMA,wBAAiC;AAC/B,eAAW,eAAe,KAAK,iBAAiB,OAAO,GAAG;AACxD,UAAI,YAAY,OAAO,WAAW,aAAa;AAC7C,eAAO;MACT;IACF;AACA,WAAO;EACT;EAMA,sBAA+B;AAC7B,WAAO,KAAK,iBAAiB,OAAO;EACtC;AACF;;;AC5KA,IAAM,2BAAN,MAA+D;EAO7D,YAAY,cAA+B;AACzC,SAAK,eAAe;AACpB,SAAK,kBAAkB,CAAC;EAC1B;EAEA,SAAS,MAAc,MAAkC;AACvD,UAAM,QAAQ,KAAK,aAAa,IAAI,qBAAqB,MAAM,IAAI,CAAC;AACpE,QAAI,UAAU,QAAW;AACvB,aAAO;IACT;AACA,WAAO,yBAAyB,WAAW,MAAM,MAAM;EACzD;EAEA,cAAc,MAA6D;AACzE,UAAM,kBAAkB,CAAC;AACzB,eAAW,SAAS,KAAK,aAAa,OAAO,GAAG;AAC9C,UAAI,MAAM,YAAY,oBAAoB,IAAI,GAAG;AAC/C,wBAAgB,KAAK;UACnB,MAAM,MAAM;UACZ,OAAO,yBAAyB,WAAW,MAAM,MAAM;QACzD,CAAC;MACH;IACF;AACA,WAAO;EACT;EAEA,SAAS,MAAc,MAAe,OAAgC;AACpE,UAAM,aAAa,qBAAqB,MAAM,IAAI;AAElD,QAAI;AACJ,QAAI,UAAU,QAAW;AACvB,eAAS;IACX,OAAO;AACL,eAAS;QACP,SAAS;QACT;MACF;IACF;AACA,UAAM,QAAe;MACnB,SAAS;MACT;MACA;IACF;AACA,SAAK,aAAa,IAAI,YAAY,KAAK;AACvC,SAAK,gBAAgB,KAAK,UAAU;EACtC;EAEA,OAAe,WACb,QACmB;AACnB,QAAI,WAAW,QAAW;AACxB,aAAO;IACT,WAAW,OAAO,SAAS;AACzB,aAAO,OAAO;IAChB,OAAO;AAKL,aAAO;IACT;EACF;AACF;AAsBO,IAAM,yBAAN,MAA6B;EAIlC,cAAc;AACZ,SAAK,eAAe,oBAAI,IAAI;AAC5B,SAAK,oBAAoB,CAAC;EAC5B;EAEA,6BACE,oBACA,yBACgB;AAChB,SAAK,oBAAoB,KAAK,kBAAkB,OAAO,CAAA,gBAAe;AACpE,aAAO,CAAC,wBAAwB,IAAI,YAAY,UAAU;IAC5D,CAAC;AAED,UAAM,kBAAkB,KAAK;AAC7B,SAAK,eAAe,IAAI,IAAI,kBAAkB;AAC9C,UAAM,aAAa,IAAI,yBAAyB,KAAK,YAAY;AACjE,eAAW,eAAe,KAAK,mBAAmB;AAChD,kBAAY,OAAO,UAAU;IAC/B;AAIA,UAAM,iBAAiC,CAAC;AACxC,eAAW,CAAC,YAAY,KAAK,KAAK,KAAK,cAAc;AACnD,YAAM,WAAW,gBAAgB,IAAI,UAAU;AAC/C,UAAI,aAAa,UAAa,SAAS,WAAW,MAAM,QAAQ;AAC9D,uBAAe,KAAK,UAAU;MAChC;IACF;AAEA,WAAO;EACT;EAEA,sBACE,QACA,YACgB;AAEhB,SAAK,kBAAkB,KAAK;MAC1B;MACA;IACF,CAAC;AACD,UAAM,aAAa,IAAI,yBAAyB,KAAK,YAAY;AACjE,WAAO,UAAU;AAIjB,WAAO,WAAW;EACpB;EAEA,YAAY,YAA2C;AACrD,UAAM,QAAQ,KAAK,aAAa,IAAI,UAAU;AAC9C,QAAI,UAAU,QAAW;AACvB,aAAO;IACT;AACA,UAAM,SAAS,MAAM;AACrB,QAAI,WAAW,QAAW;AACxB,aAAO;IACT,WAAW,OAAO,SAAS;AACzB,aAAO,OAAO;IAChB,OAAO;AACL,YAAM,YAAY,SAAS,MAAM,SAAS,OAAO,YAAY;IAC/D;EACF;AACF;;;AC9KO,IAAM,OAAN,MAAW;EAKhB,OAAO,OAAO,KAAW;AACvB,YAAQ,OAAO,IAAI,wBAAwB;EAC7C;EAEA,YAAY,KAAa,MAAc;AACrC,SAAK,MAAM,MAAM;AACjB,SAAK,OAAO,OAAO;AACnB,SAAK,qBAAqB;EAC5B;EAGA,OAAO,YAAY,OAAuB;AACxC,WAAO,IAAI;MACT,MAAM,CAAA,IACN,MAAM,CAAA,KAAM,IACZ,MAAM,CAAA,KAAM,KACZ,MAAM,CAAA,KAAM;MACZ,MAAM,CAAA,IACN,MAAM,CAAA,KAAM,IACZ,MAAM,CAAA,KAAM,KACZ,MAAM,CAAA,KAAM;IACd;EACF;EAGA,YAAY;AACV,UAAM,KAAK,KAAK;AAChB,UAAM,KAAK,KAAK;AAChB,WAAO;MACL,KAAK;MACL,OAAO,IAAI;MACX,OAAO,KAAK;MACZ,OAAO;MACP,KAAK;MACL,OAAO,IAAI;MACX,OAAO,KAAK;MACZ,OAAO;IACT;EACF;EAEA,OAAO,WAAW,OAAe;AAC/B,QAAI,MAAM,KAAK;AAAG,aAAO;AACzB,QAAI,QAAQ;AAAG,aAAO;AACtB,QAAI,SAAS;AAAgB,aAAO;AACpC,WAAO,IAAI,KAAK,QAAQ,iBAAiB,GAAI,QAAQ,iBAAkB,CAAC;EAC1E;EAEA,OAAO,OAAa;AAClB,QAAI,CAAC,KAAK,OAAO,KAAK;AAAG,cAAQ,KAAK,UAAU,KAAK;AACrD,QAAI,KAAK,SAAS,OAAO,KAAK,MAAM,SAAS,OAAO;AAAG,aAAO;AAC9D,WAAO,KAAK,SAAS,MAAM,QAAQ,KAAK,QAAQ,MAAM;EACxD;EAEA,UAAU,OAAa;AACrB,WAAO,CAAC,KAAK,OAAO,KAAK;EAC3B;EAEA,KAAK,OAAa;AAChB,QAAI,CAAC,KAAK,OAAO,KAAK;AAAG,cAAQ,KAAK,UAAU,KAAK;AACrD,QAAI,KAAK,OAAO,KAAK;AAAG,aAAO;AAC/B,WAAO,MAAM,SAAS,IAAI,KAAK,SAAS,KACrC,MAAM,SAAS,KAAK,QAAQ,MAAM,QAAQ,IAAI,KAAK,QAAQ,IAC1D,KACA;EACN;EAEA,gBAAgB,OAAa;AAC3B,WAAO,KAAK,KAAqB,KAAK,KAAK;EAC7C;EAEA,OAAO,UAAU,KAAU;AACzB,QAAI,OAAO,QAAQ;AAAU,aAAO,KAAK,WAAW,GAAG;AAEvD,WAAO,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI;EACnC;AACF;AAEA,IAAM,QAAQ,IAAI,KAAK,GAAG,CAAC;AAC3B,IAAM,iBAAiB,KAAK;AAC5B,IAAM,iBAAiB,iBAAiB;AACxC,IAAM,iBAAiB,iBAAiB;AACxC,IAAM,qBAAqB,IAAI,KAAK,aAAa,GAAG,aAAa,CAAC;;;ACpE3D,IAAM,iBAAN,MAAqB;EAK1B,YAAY,WAAgD;AAC1D,SAAK,UAAU,EAAE,UAAU,GAAG,IAAI,KAAK,WAAW,CAAC,GAAG,UAAU,EAAE;AAClE,SAAK,iBAAiB,oBAAI,IAAI;AAC9B,SAAK,YAAY;EACnB;EAEA,WAAW,YAA8B;AACvC,UAAM,QAAQ,WAAW;AACzB,QACE,KAAK,QAAQ,aAAa,MAAM,YAChC,KAAK,QAAQ,GAAG,UAAU,MAAM,EAAE,KAClC,KAAK,QAAQ,aAAa,MAAM,UAChC;AACA,YAAM,IAAI,MAAM,0BAA0B,MAAM,MAAM,MAAM,UAAU;IACxE;AACA,eAAW,gBAAgB,WAAW,eAAe;AACnD,cAAQ,aAAa,MAAM;QACzB,KAAK,gBAAgB;AACnB,gBAAM,YAAY,KAAK,UAAU,aAAa,OAAO;AACrD,cAAI,WAAW;AACb,uBAAW,QAAQ,aAAa,UAAU;AACxC,2BAAa,QAAQ,SAAS,WAAW,IAAI;YAC/C;UACF;AACA,gBAAM,QAAQ,aAAa,aAAa,SAAS,IAAI;AACrD,eAAK,eAAe,IAAI,aAAa,SAAS;YAC5C,SAAS;YACT;UACF,CAAC;AACD;QACF;QACA,KAAK,eAAe;AAClB,gBAAM,YAAY,KAAK,UAAU,aAAa,OAAO;AACrD,cAAI,WAAW;AACb,uBAAW,QAAQ,aAAa,UAAU;AACxC,2BAAa,QAAQ,SAAS,WAAW,IAAI;YAC/C;UACF;AAEA,eAAK,eAAe,IAAI,aAAa,SAAS;YAC5C,SAAS;YACT,cAAc,aAAa;UAC7B,CAAC;AACD;QACF;QACA,KAAK,gBAAgB;AACnB,eAAK,eAAe,OAAO,aAAa,OAAO;AAC/C;QACF;QACA,SAAS;AAEP,gBAAM,IAAW;AACjB,gBAAM,IAAI,MAAM,wBAAwB,cAAc;QACxD;MACF;IACF;AACA,SAAK,UAAU,WAAW;EAC5B;EAEA,qBAAgD;AAC9C,WAAO,KAAK;EACd;EAEA,YAAkB;AAChB,WAAO,KAAK,QAAQ;EACtB;AACF;;;AC/FA,IAAAC,UAAwB;AASjB,SAAS,UAAU,SAA0B;AAClD,QAAM,eAAsB,oBAAY,OAAO;AAC/C,SAAO,KAAK,YAAY,MAAM,KAAK,YAAY,CAAC;AAClD;AAEO,SAAS,mBACd,SACe;AACf,UAAQ,QAAQ,MAAM;IACpB,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK,QAAQ;AACX,aAAO,EAAE,GAAG,QAAQ;IACtB;IACA,KAAK,oBAAoB;AACvB,UAAI,QAAQ,SAAS;AACnB,eAAO,EAAE,GAAG,SAAS,IAAI,UAAU,QAAQ,EAAE,EAAE;MACjD,OAAO;AACL,eAAO,EAAE,GAAG,QAAQ;MACtB;IACF;IACA,KAAK,cAAc;AACjB,aAAO;QACL,GAAG;QACH,cAAc;UACZ,GAAG,QAAQ;UACX,IAAI,UAAU,QAAQ,aAAa,EAAE;QACvC;QACA,YAAY;UACV,GAAG,QAAQ;UACX,IAAI,UAAU,QAAQ,WAAW,EAAE;QACrC;MACF;IACF;IACA,SAAS;AACP,YAAM,uBAA8B;IACtC;EACF;AACA,SAAO;AACT;;;AC3CA,IAAM,eAAe;AACrB,IAAM,mBAAmB;AACzB,IAAM,kBAAkB;AAMxB,IAAM,kBAAkB;AA4DxB,SAAS,cAAiC;AACxC,MAAI;AACJ,QAAM,UAAU,IAAI,QAAW,CAAA,YAAW;AACxC,qBAAiB;EACnB,CAAC;AACD,SAAO,EAAE,SAAS,SAAS,eAAgB;AAC7C;AAWO,IAAM,mBAAN,MAAuB;EA6B5B,YACE,KACA,QACA,WACA,sBACA,SACA;AACA,SAAK,uBAAuB;AAC5B,SAAK,SAAS,EAAE,OAAO,eAAe;AACtC,SAAK,kBAAkB;AACvB,SAAK,kBAAkB;AAEvB,SAAK,iBAAiB;AACtB,SAAK,aAAa;AAClB,SAAK,UAAU;AAEf,SAAK,4BAA4B;AACjC,SAAK,wCAAwC;AAE7C,SAAK,MAAM;AACX,SAAK,SAAS;AACd,SAAK,YAAY;AACjB,SAAK,UAAU;AAGf,SAAK,KAAK,QAAQ;EACpB;EAEA,MAAc,UAAU;AACtB,QACE,KAAK,OAAO,UAAU,aACtB,KAAK,OAAO,UAAU,cACtB,KAAK,OAAO,UAAU,WACtB;AACA;IACF;AACA,QACE,KAAK,OAAO,UAAU,kBACtB,KAAK,OAAO,UAAU,UACtB;AACA,YAAM,IAAI,MAAM,iDAAiD;IACnE;AAEA,UAAM,KAAK,IAAI,KAAK,qBAAqB,KAAK,GAAG;AACjD,SAAK,YAAY,uBAAuB;AACxC,SAAK,SAAS;MACZ,OAAO;MACP;IACF;AACA,OAAG,SAAS,MAAM;AAChB,WAAK,YAAY,iBAAiB;AAClC,UAAI,KAAK,OAAO,UAAU,cAAc;AACtC,cAAM,IAAI,MAAM,mDAAmD;MACrE;AACA,WAAK,SAAS,EAAE,OAAO,SAAS,GAAG;AACnC,WAAK,iBAAiB;AACtB,WAAK,OAAO;QACV,iBAAiB,KAAK;QACtB,iBAAiB,KAAK;MACxB,CAAC;AAED,UAAI,KAAK,oBAAoB,kBAAkB;AAC7C,gBAAQ,IAAI,uBAAuB;MACrC;AAEA,WAAK,mBAAmB;AACxB,WAAK,kBAAkB;IACzB;AAEA,OAAG,UAAU,CAAA,UAAS;AACpB,YAAM,UAAW,MAAqB;AACtC,cAAQ,IAAI,oBAAoB,SAAS;AACzC,WAAK,kBAAkB,gBAAgB;IACzC;AACA,OAAG,YAAY,CAAA,YAAW;AAGxB,WAAK,UAAU;AACf,WAAK,iBAAiB;AACtB,YAAM,gBAAgB,mBAAmB,KAAK,MAAM,QAAQ,IAAI,CAAC;AACjE,WAAK,YAAY,iCAAiC,cAAc,MAAM;AACtE,WAAK,UAAU,aAAa;IAC9B;AACA,OAAG,UAAU,CAAA,UAAS;AACpB,UAAI,KAAK,oBAAoB,MAAM;AACjC,aAAK,kBAAkB,MAAM,UAAU;MACzC;AACA,UACE,MAAM,SAAS,gBACf,MAAM,SAAS,oBACf,MAAM,SAAS,mBACf,MAAM,SAAS,iBACf;AACA,YAAI,MAAM,2CAA2C,MAAM;AAC3D,YAAI,MAAM,QAAQ;AAChB,iBAAO,KAAK,MAAM;QACpB;AACA,gBAAQ,MAAM,GAAG;MACnB;AACA,UAAI,KAAK,OAAO,UAAU,YAAY;AACpC,aAAK,OAAO,YAAY,QAAQ,IAAI;AACpC,aAAK,SAAS,EAAE,OAAO,UAAU;AACjC;MACF;AACA,UAAI,KAAK,OAAO,UAAU,WAAW;AACnC,aAAK,OAAO,YAAY,QAAQ,IAAI;AACpC,aAAK,SAAS,EAAE,OAAO,SAAS;AAChC;MACF;AACA,WAAK,SAAS,EAAE,OAAO,eAAe;AACtC,YAAM,UAAU,KAAK,YAAY;AACjC,cAAQ,IAAI,2BAA2B,WAAW;AAClD,iBAAW,MAAM,KAAK,QAAQ,GAAG,OAAO;IAC1C;EACF;EAKA,cAAsB;AACpB,WAAO,KAAK,OAAO;EACrB;EAMA,YAAY,SAAwB;AAClC,SAAK,YAAY,6BAA6B,QAAQ,MAAM;AAC5D,QAAI,KAAK,OAAO,UAAU,SAAS;AACjC,YAAM,UAAU,KAAK,UAAU,OAAO;AACtC,UAAI;AACF,aAAK,OAAO,GAAG,KAAK,OAAO;MAC7B,SAAS,OAAT;AACE,gBAAQ;UACN,sDAAsD;QACxD;AACA,aAAK,kBAAkB,qBAAqB;MAC9C;AAEA,aAAO;IACT;AACA,WAAO;EACT;EAEQ,mBAAmB;AACzB,QAAI,KAAK,0CAA0C,MAAM;AACvD,mBAAa,KAAK,qCAAqC;AACvD,WAAK,wCAAwC;IAC/C;AACA,SAAK,wCAAwC,WAAW,MAAM;AAC5D,WAAK,kBAAkB,gBAAgB;IACzC,GAAG,KAAK,yBAAyB;EACnC;EAOQ,kBAAkB,aAAqB;AAC7C,YAAQ,KAAK,OAAO,OAAO;MACzB,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;AAEH;MACF,KAAK;MACL,KAAK;AACH,aAAK,kBAAkB;AACvB,aAAK,OAAO,GAAG,MAAM;AACrB,aAAK,SAAS;UACZ,OAAO;UACP,IAAI,KAAK,OAAO;QAClB;AACA;MACF,SAAS;AAGP,cAAM,IAAW,KAAK;MACxB;IACF;EACF;EAMA,MAAM,OAAsB;AAC1B,QAAI,KAAK,uCAAuC;AAC9C,mBAAa,KAAK,qCAAqC;IACzD;AACA,YAAQ,KAAK,OAAO,OAAO;MACzB,KAAK;AACH;MACF,KAAK;MACL,KAAK;AACH,aAAK,OAAO,GAAG,MAAM;AACrB,aAAK,SAAS;UACZ,OAAO;UACP,aAAa,YAAY;QAC3B;AACA,cAAM,KAAK,OAAO,YAAY;AAC9B;MACF,KAAK;MACL,KAAK;AAGH,aAAK,SAAS;UACZ,OAAO;UACP,aAAa,YAAY;QAC3B;AACA,cAAM,KAAK,OAAO,YAAY;AAC9B;MACF,KAAK;MACL,KAAK;AAIH,aAAK,SAAS,EAAE,OAAO,UAAU;AACjC;MACF,KAAK;AACH,cAAM,KAAK,OAAO,YAAY;AAC9B;MACF,SAAS;AAEP,cAAM,IAAW,KAAK;MACxB;IACF;EACF;EAEA,MAAM,QAAuB;AAC3B,YAAQ,KAAK,OAAO,OAAO;MACzB,KAAK;MACL,KAAK;AAEH;MACF,KAAK;AACH;MACF,KAAK;MACL,KAAK;AACH,aAAK,OAAO,GAAG,MAAM;AACrB,aAAK,SAAS;UACZ,OAAO;UACP,aAAa,YAAY;QAC3B;AACA,cAAM,KAAK,OAAO,YAAY;AAC9B;MACF,KAAK;AAGH,aAAK,SAAS;UACZ,OAAO;UACP,aAAa,YAAY;QAC3B;AACA,cAAM,KAAK,OAAO,YAAY;AAC9B;MACF,KAAK;AAGH,aAAK,SAAS,EAAE,OAAO,SAAS;AAChC;MACF,KAAK;AACH,cAAM,KAAK,OAAO,YAAY;AAC9B;MACF,SAAS;AAEP,cAAM,IAAW,KAAK;MACxB;IACF;EACF;EAMA,MAAM,SAAwB;AAC5B,YAAQ,KAAK,OAAO,OAAO;MACzB,KAAK;MACL,KAAK;AACH;MACF,KAAK;MACL,KAAK;AAEH;MACF,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;AACH,cAAM,IAAI,MAAM,0CAA0C;MAC5D,SAAS;AAEP,cAAM,IAAW,KAAK;MACxB;IACF;AACA,QAAI,KAAK,OAAO,UAAU,WAAW;AACnC,YAAM,KAAK,OAAO,YAAY;IAChC;AACA,UAAM,KAAK,QAAQ;EACrB;EAEQ,YAAY,SAAiB;AACnC,QAAI,KAAK,SAAS;AAChB,cAAQ,MAAM,IAAG,oBAAI,KAAK,GAAE,YAAY,KAAK,SAAS;IACxD;EACF;EAEQ,cAAsB;AAC5B,UAAM,cAAc,KAAK,iBAAiB,KAAK,IAAI,GAAG,KAAK,OAAO;AAClE,SAAK,WAAW;AAChB,UAAM,gBAAgB,KAAK,IAAI,aAAa,KAAK,UAAU;AAC3D,UAAM,SAAS,iBAAiB,KAAK,OAAO,IAAI;AAChD,WAAO,gBAAgB;EACzB;AACF;;;ACrbO,SAAS,eAAe;AAC7B,SAAO,OAAO;AAChB;AAGA,SAAS,SAAS;AAChB,SAAO,uCAAuC,QAAQ,SAAS,CAAA,MAAK;AAClE,UAAM,IAAK,KAAK,OAAO,IAAI,KAAM,GAC/B,IAAI,MAAM,MAAM,IAAK,IAAI,IAAO;AAClC,WAAO,EAAE,SAAS,EAAE;EACtB,CAAC;AACH;;;AC4EO,IAAM,uBAAN,MAA2B;EAkBhC,YACE,SACA,cACA,SACA;AAbF,SAAQ,aAAgE;AActE,QAAI,OAAO,YAAY,UAAU;AAC/B,YAAM,IAAI;QACR;MACF;IACF;AACA,cAAU,EAAE,GAAG,QAAQ;AACvB,QAAI,uBAAuB,QAAQ;AACnC,QAAI,CAAC,wBAAwB,OAAO,cAAc,aAAa;AAC7D,YAAM,IAAI;QACR;MACF;IACF;AACA,2BAAuB,wBAAwB;AAC/C,UAAM,UAAU,QAAQ,WAAW;AAGnC,UAAM,IAAI,QAAQ,OAAO,KAAK;AAC9B,QAAI,MAAM,IAAI;AACZ,YAAM,IAAI,MAAM,2CAA2C;IAC7D;AACA,UAAM,SAAS,QAAQ,UAAU,IAAI,CAAC;AACtC,UAAM,WAAW,QAAQ,UAAU,GAAG,CAAC;AACvC,QAAI;AACJ,QAAI,aAAa,QAAQ;AACvB,mBAAa;IACf,WAAW,aAAa,SAAS;AAC/B,mBAAa;IACf,OAAO;AACL,YAAM,IAAI,MAAM,2BAA2B,UAAU;IACvD;AACA,UAAM,QAAQ,GAAG,gBAAgB,cAAc;AAE/C,SAAK,QAAQ,IAAI,eAAe;AAChC,SAAK,iBAAiB,IAAI;MAAe,CAAA,YACvC,KAAK,MAAM,UAAU,OAAO;IAC9B;AACA,SAAK,iBAAiB,IAAI,eAAe;AACzC,SAAK,yBAAyB,IAAI,uBAAuB;AACzD,SAAK,eAAe;AACpB,SAAK,gBAAgB;AACrB,SAAK,YAAY,aAAa;AAE9B,UAAM,EAAE,sBAAsB,IAAI;AAClC,QAAI,OAAO,WAAW,aAAa;AACjC,UAAI,0BAA0B,MAAM;AAClC,cAAM,IAAI;UACR;QACF;MACF;IACF,WAAW,0BAA0B,OAAO;AAE1C,aAAO,iBAAiB,gBAAgB,CAAA,MAAK;AAC3C,YAAI,KAAK,eAAe,sBAAsB,GAAG;AAI/C,YAAE,eAAe;AAGjB,gBAAM,sBACJ;AACF,WAAC,KAAK,OAAO,OAAO,cAAc;AAClC,iBAAO;QACT;MACF,CAAC;IACH;AAEA,SAAK,mBAAmB,IAAI;MAC1B;MACA,CAAC,sBAAyC;AAGxC,aAAK,iBAAiB,YAAY;UAChC,GAAG;UACH,MAAM;UACN,WAAW,KAAK;QAClB,CAAC;AAID,aAAK,iBAAiB,IAAI;UAAe,CAAA,YACvC,KAAK,MAAM,UAAU,OAAO;QAC9B;AACA,cAAM,CAAC,sBAAsB,gBAAgB,IAAI,KAAK,MAAM,QAAQ;AACpE,YAAI,kBAAkB;AACpB,eAAK,iBAAiB,YAAY,gBAAgB;QACpD;AACA,aAAK,iBAAiB,YAAY,oBAAoB;AACtD,mBAAW,WAAW,KAAK,eAAe,QAAQ,GAAG;AACnD,eAAK,iBAAiB,YAAY,OAAO;QAC3C;MACF;MACA,CAAC,kBAAiC;AAChC,gBAAQ,cAAc,MAAM;UAC1B,KAAK,cAAc;AACjB,iBAAK,eAAe,WAAW,aAAa;AAC5C,iBAAK,MAAM,kBAAkB,aAAa;AAC1C,kBAAM,oBAAoB,KAAK,eAAe;cAC5C,KAAK,eAAe,UAAU;YAChC;AACA,iBAAK,2BAA2B,iBAAiB;AACjD;UACF;UACA,KAAK,oBAAoB;AACvB,kBAAM,sBACJ,KAAK,eAAe,WAAW,aAAa;AAC9C,gBAAI,qBAAqB;AACvB,mBAAK,2BAA2B,oBAAI,IAAI,CAAC,mBAAmB,CAAC,CAAC;YAChE;AACA;UACF;UACA,KAAK,kBAAkB;AACrB,iBAAK,eAAe,WAAW,aAAa;AAC5C;UACF;UACA,KAAK,aAAa;AAChB,iBAAK,oBAAoB,aAAa,EACnC,KAAK,EACL,MAAM,CAAA,UAAS;AACd,4BAAc,KAAK;AAEnB,mBAAK,KAAK,iBAAiB,KAAK;YAClC,CAAC;AACH;UACF;UACA,KAAK,cAAc;AACjB,kBAAM,QAAQ,cAAc,cAAc,KAAK;AAC/C,iBAAK,KAAK,iBAAiB,KAAK;AAChC,kBAAM;UACR;UACA,KAAK;AACH;UACF,SAAS;AACP,kBAAM,aAAoB;UAC5B;QACF;MACF;MACA;MACA;IACF;EACF;EAUQ,2BAA2B,kBAAkC;AACnE,UAAM,qBACJ,KAAK,eAAe,mBAAmB;AACzC,UAAM,oBAAqC,oBAAI,IAAI;AACnD,eAAW,CAAC,SAAS,MAAM,KAAK,oBAAoB;AAClD,YAAM,aAAa,KAAK,MAAM,WAAW,OAAO;AAIhD,UAAI,eAAe,MAAM;AACvB,cAAM,QAAQ;UACZ;UACA,SAAS,KAAK,MAAM,UAAU,OAAO;UACrC,MAAM,KAAK,MAAM,UAAU,OAAO;QACpC;AACA,0BAAkB,IAAI,YAAY,KAAK;MACzC;IACF;AAEA,SAAK;MACH,KAAK,uBAAuB;QAC1B;QACA;MACF;IACF;EACF;EAEA,MAAM,QAAQ,YAA8B;AAC1C,SAAK,aAAa;AAClB,UAAM,QAAQ,MAAM,WAAW;AAC/B,QAAI,OAAO;AACT,WAAK,aAAa,KAAK;IACzB,WAAW,KAAK,MAAM,QAAQ,GAAG;AAC/B,WAAK,UAAU;IACjB;EACF;EAGA,MAAc,oBAAoB,eAA0B;AAC1D,QAAI,CAAC,KAAK,YAAY;AACpB,YAAM,IAAI,MAAM,cAAc,KAAK;IACrC;AACA,YAAQ,IAAI,8BAA8B;AAC1C,UAAM,KAAK,iBAAiB,MAAM;AAClC,UAAM,QAAQ,MAAM,KAAK,WAAW;AACpC,QAAI,SAAS,KAAK,MAAM,UAAU,KAAK,GAAG;AACxC,WAAK,MAAM,QAAQ,KAAK;IAC1B,WAAW,KAAK,MAAM,QAAQ,GAAG;AAC/B,cAAQ,IAAI,wCAAwC;AACpD,WAAK,MAAM,UAAU;IACvB;AACA,UAAM,KAAK,iBAAiB,OAAO;EACrC;EAEA,UAAU;AACR,WAAO,KAAK,MAAM,QAAQ;EAC5B;EAEQ,aAAa,OAAe;AAClC,UAAM,UAAU,KAAK,MAAM,QAAQ,KAAK;AACxC,SAAK,iBAAiB,YAAY,OAAO;EAC3C;EAGA,aAAa,OAAe,kBAA2C;AACrE,UAAM,UAAU,KAAK,MAAM,aAAa,OAAO,gBAAgB;AAC/D,SAAK,iBAAiB,YAAY,OAAO;EAC3C;EAEA,YAAY;AACV,UAAM,UAAU,KAAK,MAAM,UAAU;AACrC,SAAK,iBAAiB,YAAY,OAAO;EAC3C;EAgBA,UACE,MACA,MACA,SACqD;AAIrD,QAAI,CAAC,MAAM,QAAQ,IAAI,GAAG;AACxB,YAAM,IAAI;QACR,mFAAmF;MACrF;IACF;AAEA,UAAM,EAAE,cAAc,YAAY,YAAY,IAAI,KAAK,MAAM;MAC3D;MACA;MACA;IACF;AACA,QAAI,iBAAiB,MAAM;AACzB,WAAK,iBAAiB,YAAY,YAAY;IAChD;AAEA,WAAO;MACL;MACA,aAAa,MAAM;AACjB,cAAMC,gBAAe,YAAY;AACjC,YAAIA,eAAc;AAChB,eAAK,iBAAiB,YAAYA,aAAY;QAChD;MACF;IACF;EACF;EAQA,iBAAiB,SAAiB,MAAgC;AAChE,UAAM,aAAa,qBAAqB,SAAS,IAAI;AACrD,WAAO,KAAK,uBAAuB,YAAY,UAAU;EAC3D;EAWA,aAAa,MAAc,MAAuC;AAChE,UAAM,aAAa,qBAAqB,MAAM,IAAI;AAClD,WAAO,KAAK,MAAM,aAAa,UAAU;EAC3C;EAQA,kBAAmC;AACjC,WAAO;MACL,qBAAqB,KAAK,eAAe,oBAAoB;MAC7D,sBAAsB,KAAK,iBAAiB,YAAY,MAAM;IAChE;EACF;EAEA,MAAM,OACJ,SACA,MACA,mBAA8D,MAChD;AACd,UAAM,YAAY,KAAK;AACvB,SAAK;AAEL,QAAI,qBAAqB,MAAM;AAC7B,YAAM,gBAAgB,CAAC,oBAA0C;AAC/D,yBAAiB,iBAAiB,GAAG,IAAI;MAC3C;AACA,YAAM,iBAAiB,KAAK,uBAAuB;QACjD;QACA;MACF;AACA,WAAK,aAAa,cAAc;IAClC;AAEA,UAAM,UAA2B;MAC/B,MAAM;MACN;MACA;MACA,MAAM,aAAa,IAAI;IACzB;AACA,UAAM,cAAc,KAAK,iBAAiB,YAAY,OAAO;AAC7D,WAAO,KAAK,eAAe,QAAQ,SAAS,WAAW;EACzD;EAEA,MAAM,OAA2B,SAAiB,MAA0B;AAC1E,UAAM,YAAY,KAAK;AACvB,SAAK;AAEL,UAAM,UAAyB;MAC7B,MAAM;MACN;MACA;MACA,MAAM,aAAa,IAAI;IACzB;AAEA,UAAM,cAAc,KAAK,iBAAiB,YAAY,OAAO;AAC7D,WAAO,KAAK,eAAe,QAAQ,SAAS,WAAW;EACzD;EAEA,MAAM,QAAuB;AAC3B,WAAO,KAAK,iBAAiB,KAAK;EACpC;AACF;;;AClcA,IAAMC,SACJ,WAAW,UACV,IAAI,SACH,OAAO,mBAAA,EAAc;EAAK,CAAC,EAAE,SAASA,QAAM,MACzCA,QAAiC,GAAG,IAAI;AAC3C;;;ACuEJ,IAAAC,gBAA2C;AAE3C,uBAAqB;;;AC/FrB,mBAAoC;AAa7B,SAAS,gBAAuB;EAErC;EAIA;AACF,GAGU;AAKR,QAAM,CAAC,OAAO,QAAQ,QAAI,uBAAS,OAAO;IACxC;IACA;IACA,OAAO,gBAAgB;EACzB,EAAE;AAEF,MAAI,gBAAgB,MAAM;AAG1B,MACE,MAAM,oBAAoB,mBAC1B,MAAM,cAAc,WACpB;AAIA,oBAAgB,gBAAgB;AAEhC,aAAS;MACP;MACA;MACA,OAAO;IACT,CAAC;EACH;AAWA,8BAAU,MAAM;AACd,QAAI,iBAAiB;AAErB,UAAM,kBAAkB,MAAM;AAK5B,UAAI,gBAAgB;AAClB;MACF;AAEA,eAAS,CAAA,cAAa;AAKpB,YACE,UAAU,oBAAoB,mBAC9B,UAAU,cAAc,WACxB;AACA,iBAAO;QACT;AAKA,cAAM,QAAQ,gBAAgB;AAC9B,YAAI,UAAU,UAAU,OAAO;AAC7B,iBAAO;QACT;AAEA,eAAO,EAAE,GAAG,WAAW,MAAM;MAC/B,CAAC;IACH;AACA,UAAM,cAAc,UAAU,eAAe;AAK7C,oBAAgB;AAEhB,WAAO,MAAM;AACX,uBAAiB;AACjB,kBAAY;IACd;EACF,GAAG,CAAC,iBAAiB,SAAS,CAAC;AAG/B,SAAO;AACT;;;AChHA,IAAAC,gBAAkC;;;ACClC,IAAAC,gBAA6C;;;ACuBtC,IAAM,kBAAN,MAAsB;EAK3B,YAAY,aAA0B;AACpC,SAAK,cAAc;AACnB,SAAK,UAAU,CAAC;AAChB,SAAK,YAAY,oBAAI,IAAI;EAC3B;EAEA,WAAW,YAAiE;AAG1E,eAAW,cAAc,OAAO,KAAK,UAAU,GAAG;AAChD,YAAM,EAAE,MAAM,KAAK,IAAI,WAAW,UAAA;AAElC,UAAI,KAAK,QAAQ,UAAA,MAAgB,QAAW;AAE1C,aAAK,SAAS,YAAY,MAAM,IAAI;MACtC,OAAO;AACL,cAAM,eAAe,KAAK,QAAQ,UAAA;AAClC,YACE,SAAS,aAAa,QACtB,KAAK,UAAU,aAAa,IAAI,CAAC,MAC/B,KAAK,UAAU,aAAa,aAAa,IAAI,CAAC,GAChD;AAEA,eAAK,YAAY,UAAU;AAC3B,eAAK,SAAS,YAAY,MAAM,IAAI;QACtC;MACF;IACF;AAGA,eAAW,cAAc,OAAO,KAAK,KAAK,OAAO,GAAG;AAClD,UAAI,WAAW,UAAA,MAAgB,QAAW;AACxC,aAAK,YAAY,UAAU;MAC7B;IACF;EACF;EAEA,UAAU,UAAkC;AAC1C,SAAK,UAAU,IAAI,QAAQ;AAC3B,WAAO,MAAM;AACX,WAAK,UAAU,OAAO,QAAQ;IAChC;EACF;EAEA,oBAAmE;AACjE,UAAM,SAAwD,CAAC;AAC/D,eAAW,cAAc,OAAO,KAAK,KAAK,OAAO,GAAG;AAClD,UAAI;AACJ,UAAI;AACF,gBAAQ,KAAK,QAAQ,UAAA,EAAY,MAAM,iBAAiB;MAC1D,SAAS,GAAT;AAGE,YAAI,aAAa,OAAO;AACtB,kBAAQ;QACV,OAAO;AACL,gBAAM;QACR;MACF;AACA,aAAO,UAAA,IAAc;IACvB;AACA,WAAO;EACT;EAEA,eAAe,aAA0B;AACvC,SAAK,cAAc;AAGnB,eAAW,cAAc,OAAO,KAAK,KAAK,OAAO,GAAG;AAClD,YAAM,EAAE,MAAM,MAAM,MAAM,IAAI,KAAK,QAAQ,UAAA;AAC3C,YAAM,UAAU,MAAM,QAAQ;AAC9B,WAAK,YAAY,UAAU;AAC3B,WAAK,SAAS,YAAY,MAAM,MAAM,OAAO;IAC/C;EACF;EAEA,UAAU;AACR,eAAW,cAAc,OAAO,KAAK,KAAK,OAAO,GAAG;AAClD,WAAK,YAAY,UAAU;IAC7B;AACA,SAAK,YAAY,oBAAI,IAAI;EAC3B;EAEQ,SACN,YACA,MACA,MACA,SACA;AACA,QAAI,KAAK,QAAQ,UAAA,MAAgB,QAAW;AAC1C,YAAM,IAAI;QACR,4CAA4C;MAC9C;IACF;AACA,UAAM,QAAQ,KAAK,YAAY,MAAM,MAAM,OAAO;AAClD,UAAM,cAAc,MAAM,SAAS,MAAM,KAAK,gBAAgB,CAAC;AAC/D,SAAK,QAAQ,UAAA,IAAc;MACzB;MACA;MACA;MACA;IACF;EACF;EAEQ,YAAY,YAAwB;AAC1C,UAAM,OAAO,KAAK,QAAQ,UAAA;AAC1B,QAAI,SAAS,QAAW;AACtB,YAAM,IAAI,MAAM,kCAAkC,aAAa;IACjE;AACA,SAAK,YAAY;AACjB,WAAO,KAAK,QAAQ,UAAA;EACtB;EAEQ,kBAAwB;AAC9B,eAAW,YAAY,KAAK,WAAW;AACrC,eAAS;IACX;EACF;AACF;;;ADtFO,SAAS,kBACd,SACyC;AACzC,QAAM,SAAS,iBAAiB;AAChC,MAAI,WAAW,QAAW;AACxB,UAAM,IAAI;MACR;IAGF;EACF;AACA,QAAM,kBAAc,uBAAQ,MAAM;AAChC,WAAO,CAAC,MAAc,MAAe,YAA2B;AAC9D,aAAO,OAAO,WAAW,MAAM,MAAM,OAAO;IAC9C;EACF,GAAG,CAAC,MAAM,CAAC;AACX,SAAO,iBAAiB,SAAS,WAAW;AAC9C;AAKO,SAAS,iBACd,SACA,aACyC;AACzC,QAAM,CAAC,QAAQ,QAAI,wBAAS,MAAM,IAAI,gBAAgB,WAAW,CAAC;AAClE,QAAM,CAAC,WAAW,YAAY,QAAI,wBAAS,KAAK;AAEhD,MAAI,SAAS,gBAAgB,aAAa;AACxC,aAAS,eAAe,WAAW;EACrC;AAGA,+BAAU,MAAM;AACd,iBAAa,IAAI;AACjB,WAAO,MAAM;AACX,eAAS,QAAQ;IACnB;EACF,GAAG,CAAC,QAAQ,CAAC;AAEb,QAAM,mBAAe,uBAAQ,MAAM;AAajC,QAAI,WAAW;AACb,eAAS,WAAW,OAAO;IAC7B;AAEA,WAAO;MACL,iBAAiB,MAAM;AACrB,YAAI,WAAW;AACb,iBAAO,SAAS,kBAAkB;QACpC,OAAO;AAKL,gBAAM,QAAmC,CAAC;AAC1C,qBAAW,cAAc,OAAO,KAAK,OAAO,GAAG;AAC7C,kBAAM,UAAA,IAAc;UACtB;AACA,iBAAO;QACT;MACF;MACA,WAAW,CAAC,aAAyB,SAAS,UAAU,QAAQ;IAClE;EACF,GAAG,CAAC,UAAU,SAAS,SAAS,CAAC;AAEjC,SAAO,gBAAgB,YAAY;AACrC;;;ADzFO,SAAS,yBACd,MACA,YACG,MAC2B;AAC9B,MACE,QAAO,mCAAS,qBAAoB,YACpC,QAAQ,kBAAkB,GAC1B;AACA,UAAM,IAAI;MACR,qEAAqE,mCAAS;IAChF;EACF;AAEA,QAAM,yBAAqB,uBAAQ,MAAM;AACvC,WAAO,MAAM;AACX,YAAM,KAAK,iBAAiB;AAC5B,aAAO;QACL;QACA;QACA;QACA,eAAe;QACf,SAAS;UACP,GAAG;YACD;YACA,MAAM;cACJ;gBACE,UAAU,QAAQ;gBAClB,QAAQ;gBACR;cACF;cACA,GAAG;YACL;UACF;QACF;MACF;IACF;EAKF,GAAG,CAAC,KAAK,UAAU,aAAa,IAAI,CAAC,GAAG,MAAM,QAAQ,eAAe,CAAC;AAEtE,QAAM,CAAC,OAAO,QAAQ,QAAI,wBAMvB,kBAAkB;AAGrB,MAAI,YAAY;AAChB,MACE,SAAS,MAAM,QACf,KAAK,UAAU,aAAa,IAAI,CAAC,MAC/B,KAAK,UAAU,aAAa,MAAM,IAAI,CAAC,GACzC;AACA,gBAAY,mBAAmB;AAC/B,aAAS,SAAS;EACpB;AAEA,QAAM,gBAAgB,kBAAkB,UAAU,OAAO;AAEzD,QAAM,CAAC,SAAS,eAAe,QAG3B,uBAAQ,MAAM;AAChB,QAAI,aAAa;AAEjB,UAAM,WAAW,CAAC;AAClB,aAAS,IAAI,GAAG,KAAK,UAAU,eAAe,KAAK;AACjD,mBAAa,cAAc,CAAA;AAC3B,UAAI,eAAe,QAAW;AAC5B;MACF;AAEA,UAAI,sBAAsB,OAAO;AAC/B,YACE,WAAW,QAAQ,SAAS,eAAe,KAC3C,WAAW,QAAQ,SAAS,8BAA8B,GAC1D;AAYA,mBAAS,kBAAkB;AAC3B,iBAAO,CAAC,CAAC,GAAG,MAAS;QACvB,OAAO;AACL,gBAAM;QACR;MACF;AACA,eAAS,KAAK,GAAG,WAAW,IAAI;IAClC;AACA,WAAO,CAAC,UAAU,UAAU;EAC9B,GAAG,CAAC,eAAe,UAAU,eAAe,kBAAkB,CAAC;AAE/D,QAAM,wBAAoB,uBAAQ,MAAM;AACtC,QAAI,oBAAoB,QAAW;AACjC,aAAO;QACL,QAAQ;QACR,UAAU;MACZ;IACF;AACA,QAAI,gBAAgB,QAAQ;AAC1B,aAAO;QACL,QAAQ;QACR,UAAU;MACZ;IACF;AACA,UAAM,iBAAiB,gBAAgB;AACvC,QAAI,qBAAqB;AACzB,WAAO;MACL,QAAQ;MACR,UAAU,CAAC,aAAqB;AAC9B,YAAI,CAAC,oBAAoB;AACvB,+BAAqB;AACrB,mBAAS,CAAA,cAAa;AACpB,kBAAM,gBAAgB,UAAU,gBAAgB;AAChD,kBAAM,UAAU,EAAE,GAAG,UAAU,QAAQ;AACvC,oBAAQ,aAAA,IAAiB;cACvB,MAAM,UAAU;cAChB,MAAM;gBACJ,EAAE,UAAU,QAAQ,gBAAgB,IAAI,UAAU,GAAG;gBACrD,GAAG,UAAU;cACf;YACF;AACA,mBAAO;cACL,GAAG;cACH;cACA;YACF;UACF,CAAC;QACH;MACF;IACF;EACF,GAAG,CAAC,eAAe,CAAC;AAEpB,SAAO;IACL;IACA,GAAG;EACL;AACF;AAEA,IAAI,eAAe;AAyBnB,SAAS,mBAA2B;AAClC;AACA,SAAO;AACT;AA6IO,SAAS,0CAId,YACA,MACA,MACA,aAGM;AAIN,QAAM,eAAe,KAAK,UAAU,aAAa,IAAI,CAAC;AAEtD,aAAW,SAAS,WAAW,cAAc,IAAI,GAAG;AAClD,QACE,MAAM,UAAU,UAChB,MAAM,KAAK,UAAU,KACrB,KAAK,UAAU,aAAa,MAAM,KAAK,MAAM,CAAC,CAAC,CAAC,MAAM,cACtD;AACA,YAAM,QAAQ,MAAM;AACpB,UACE,OAAO,UAAU,YACjB,UAAU,QACV,MAAM,QAAQ,MAAM,IAAI,GACxB;AACA,mBAAW,SAAS,MAAM,MAAM,MAAM;UACpC,GAAG;UACH,MAAM,MAAM,KAAK,IAAI,WAAW;QAClC,CAAC;MACH;IACF;EACF;AACF;;;AG7YO,SAAS,iBAGd,MAAgD;AAChD,QAAM,oBAAoB,mBAAmB,IAAI;AAEjD,SAAO,OAAO,SAAmC;AAC/C,UAAM,UAAU,MAAM,kBAAkB;AACxC,UAAM,MAAM,MAAM,MAAM,SAAS;MAC/B,QAAQ;MACR,SAAS,EAAE,gBAAgB,KAAK,KAAK;MACrC,MAAM;IACR,CAAC;AACD,QAAI,IAAI,WAAW,KAAK;AACtB,YAAM,EAAE,UAAU,IAAI,MAAM,IAAI,KAAK;AACrC,aAAO;IACT,OAAO;AACL,YAAM,EAAE,MAAM,QAAQ,IAAI,MAAM,IAAI,KAAK;AACzC,cAAQ,MAAM,GAAG,IAAI,UAAU,IAAI,eAAe,SAAS,SAAS;AACpE,YAAM,IAAI,MAAM,GAAG,IAAI,UAAU,IAAI,eAAe,SAAS,SAAS;IACxE;EACF;AACF;;;AC/BA,IAAAC,gBAMO;AAoBP,IAAM,wBAAoB,6BAA+B,MAAgB;AAYlE,SAAS,gBAGd;AACA,aAAO,0BAAW,iBAAiB;AACrC;AAcO,SAAS,uBAAuB;EACrC;EACA;EACA;AACF,GAQG;AACD,QAAM,EAAE,WAAW,iBAAiB,iBAAiB,IAAI,QAAQ;AACjE,QAAM,CAAC,uBAAuB,wBAAwB,QAAI,wBAExD,IAAI;AAEN,+BAAU,MAAM;AACd,QAAI,uBAAuB;AAE3B,mBAAe,WAAW;AACxB,YAAM,OAAO,QAAQ,gBAAgB;AACrC,UAAI,sBAAsB;AACxB,iCAAyB,IAAI;MAC/B;IACF;AAEA,QAAI,iBAAiB;AACnB,WAAK,SAAS;AACd,aAAO,MAAM;AACX,+BAAuB;AAIvB;UAAyB,CAAAC,2BACvBA,yBAAwB,QAAQ;QAClC;AACA,eAAO,UAAU;MACnB;IACF;EACF,GAAG,CAAC,iBAAiB,kBAAkB,WAAW,MAAM,CAAC;AAMzD,MAAI,aAAa,0BAA0B,MAAM;AAC/C,6BAAyB,IAAI;EAC/B;AAEA,MAAI,CAAC,aAAa,CAAC,mBAAmB,0BAA0B,OAAO;AACrE,6BAAyB,KAAK;EAChC;AAEA,SACE,cAAAC,QAAA;IAAC,kBAAkB;IAAlB;MACC,OAAO;QACL,WAAW,0BAA0B;QACrC,iBAAiB,oBAAoB,yBAAyB;MAChE;IAAA;IAEA,cAAAA,QAAA,cAAC,gBAAA,EAAe,OAAA,GAAwB,QAAS;EACnD;AAEJ;;;AClHO,SAAS,cAAc,EAAE,SAAS,GAA4B;AACnE,QAAM,EAAE,WAAW,gBAAgB,IAAI,cAAc;AACrD,MAAI,aAAa,CAAC,iBAAiB;AACjC,WAAO;EACT;AACA,SAAO;AACT;AAOO,SAAS,gBAAgB,EAAE,SAAS,GAA4B;AACrE,QAAM,EAAE,WAAW,gBAAgB,IAAI,cAAc;AACrD,MAAI,aAAa,iBAAiB;AAChC,WAAO;EACT;AACA,SAAO;AACT;AAQO,SAAS,YAAY,EAAE,SAAS,GAA4B;AACjE,QAAM,EAAE,UAAU,IAAI,cAAc;AACpC,MAAI,CAAC,WAAW;AACd,WAAO;EACT;AACA,SAAO;AACT;;;APuEA,IAAI,OAAO,cAAAC,YAAU,aAAa;AAChC,QAAM,IAAI,MAAM,2CAA2C;AAC7D;AACA,IAAI,OAAO,iBAAAC,YAAa,aAAa;AACnC,QAAM,IAAI,MAAM,+CAA+C;AACjE;AAoDA,SAAS,eAIP,MACA,MACA,SAGW,MACe;AAC1B,WAAS,YACJ,MAC4C;AAC/C,gCAA4B,IAAI;AAChC,WAAO,KAAK,EAAE,OAAO,MAAM,MAAM,MAAM;EACzC;AACA,WAAS,uBAAuB,SAAS,qBACvC,kBAI0B;AAC1B,QAAI,WAAW,MAAM;AACnB,YAAM,IAAI;QACR,oDAAoD;MACtD;IACF;AACA,WAAO,eAAe,MAAM,MAAM,gBAAgB;EACpD;AACA,SAAO;AACT;AAuBA,SAAS,aAGP,MAAY,MAA0D;AACtE,SAAO,YACF,MAC0C;AAC7C,WAAO,KAAK,EAAE,OAAO,MAAM,IAAI;EACjC;AACF;AAgFO,IAAM,oBAAN,MAAgD;EAerD,YAAY,SAAiB,SAA8B;AAV3D,SAAQ,SAAS;AAaf,QAAI,OAAO,YAAY,UAAU;AAC/B,YAAM,IAAI;QACR;MACF;IACF;AACA,QAAI,CAAC,QAAQ,SAAS,KAAK,GAAG;AAC5B,YAAM,IAAI,MAAM,2CAA2C;IAC7D;AACA,SAAK,UAAU;AACf,SAAK,YAAY,oBAAI,IAAI;AACzB,SAAK,UAAU,EAAE,GAAG,QAAQ;EAC9B;EAMA,IAAY,OAAO;AACjB,QAAI,KAAK,QAAQ;AACf,YAAM,IAAI,MAAM,4CAA4C;IAC9D;AACA,QAAI,KAAK,YAAY;AACnB,aAAO,KAAK;IACd;AACA,SAAK,aAAa,IAAI;MACpB,KAAK;MACL,CAAA,mBAAkB,KAAK,WAAW,cAAc;MAChD,KAAK;IACP;AACA,QAAI,KAAK,WAAW;AAClB,WAAK,WAAW,aAAa,KAAK,WAAW,KAAK,gBAAgB;IACpE;AACA,WAAO,KAAK;EACd;EASA,MAAM,QAAQ,YAA6C;AACzD,QAAI,OAAO,eAAe,UAAU;AAClC,YAAM,IAAI;QACR;MAEF;IACF;AACA,WAAO,MAAM,KAAK,KAAK,QAAQ,UAAU;EAC3C;EAKA,YAAY;AACV,SAAK,KAAK,UAAU;EACtB;EAKA,aAAa,OAAe,UAAmC;AAC7D,SAAK,YAAY;AACjB,SAAK,mBAAmB;AACxB,QAAI,KAAK,QAAQ;AACf,YAAM,IAAI,MAAM,4CAA4C;IAC9D;AACA,QAAI,KAAK,YAAY;AACnB,WAAK,KAAK,aAAa,OAAO,QAAQ;IACxC;EACF;EAeA,WACE,MACA,MACA,SAC0C;AAI1C,QAAI,CAAC,MAAM,QAAQ,IAAI,GAAG;AACxB,YAAM,IAAI;QACR,kFAAkF;MACpF;IACF;AACA,WAAO;MACL,UAAU,CAAA,aAAY;AACpB,cAAM,EAAE,YAAY,YAAY,IAAI,KAAK,KAAK;UAC5C;UACA;UACA;QACF;AAEA,cAAM,mBAAmB,KAAK,UAAU,IAAI,UAAU;AACtD,YAAI,qBAAqB,QAAW;AAClC,2BAAiB,IAAI,QAAQ;QAC/B,OAAO;AACL,eAAK,UAAU,IAAI,YAAY,oBAAI,IAAI,CAAC,QAAQ,CAAC,CAAC;QACpD;AAEA,eAAO,MAAM;AACX,cAAI,KAAK,QAAQ;AACf;UACF;AAEA,gBAAMC,oBAAmB,KAAK,UAAU,IAAI,UAAU;AACtDA,4BAAiB,OAAO,QAAQ;AAChC,cAAIA,kBAAiB,SAAS,GAAG;AAC/B,iBAAK,UAAU,OAAO,UAAU;UAClC;AACA,sBAAY;QACd;MACF;MAEA,kBAAkB,MAAM;AAGtB,YAAI,KAAK,YAAY;AACnB,iBAAO,KAAK,WAAW,iBAAiB,MAAM,IAAI;QAGpD;AACA,eAAO;MACT;MAEA,SAAS,MAAM;AACb,YAAI,KAAK,YAAY;AACnB,iBAAO,KAAK,WAAW,aAAa,MAAM,IAAI;QAChD;AACA,eAAO;MACT;IACF;EACF;EAQA,SACE,MAC0B;AAC1B,WAAO,eAAe,MAAM,MAAM,KAAK,IAAI;EAC7C;EAQA,OACE,MACwB;AACxB,WAAO,aAAa,MAAM,MAAM,KAAK,IAAI;EAC3C;EAQA,kBAAmC;AACjC,WAAO,KAAK,KAAK,gBAAgB;EACnC;EAUA,MAAM,QAAuB;AAC3B,SAAK,SAAS;AAEd,SAAK,YAAY,oBAAI,IAAI;AACzB,QAAI,KAAK,YAAY;AACnB,YAAM,OAAO,KAAK;AAClB,WAAK,aAAa;AAClB,YAAM,KAAK,MAAM;IACnB;EACF;EAEQ,WAAW,gBAA8B;AAC/C,qBAAAD,QAAS,wBAAwB,MAAM;AACrC,iBAAW,cAAc,gBAAgB;AACvC,cAAM,YAAY,KAAK,UAAU,IAAI,UAAU;AAC/C,YAAI,WAAW;AACb,qBAAW,YAAY,WAAW;AAChC,qBAAS;UACX;QACF;MACF;IACF,CAAC;EACH;AACF;AAEA,IAAM,gBAAgB,cAAAD,QAAM;EAC1B;AACF;AAcO,SAAS,mBAEY;AAC1B,aAAO,0BAAW,aAAa;AACjC;AAYO,IAAM,iBAGR,CAAC,EAAE,QAAQ,SAAS,MAAM;AAC7B,SAAO,cAAAA,QAAM;IACX,cAAc;IACd,EAAE,OAAO,OAAO;IAChB;EACF;AACF;AAmBO,SAAS,gBAId,SACG,MAC4C;AAC/C,QAAM,aAAS,0BAAW,aAAa;AACvC,MAAI,WAAW,QAAW;AACxB,UAAM,IAAI;MACR;IAGF;EACF;AAEA,SAAO,iBAAiB,QAAQ,MAAM,GAAG,IAAI;AAC/C;AAUO,SAAS,iBAId,QACA,SACG,MAC4C;AAC/C,QAAM,mBAAe;IACnB,MAAM;AACJ,YAAM,QAAQ,OAAO,WAAW,MAAM,IAAI;AAC1C,aAAO;QACL,iBAAiB,MAAM,MAAM,iBAAiB;QAC9C,WAAW,CAAC,aAAyB,MAAM,SAAS,QAAQ;MAC9D;IACF;IAKA,CAAC,MAAM,QAAQ,KAAK,UAAU,aAAa,IAAI,CAAC,CAAC;EACnD;AAEA,QAAM,cAAc,gBAAgB,YAAY;AAChD,SAAO;AACT;AAuBO,SAAS,mBAGd,MAAsC;AACtC,QAAM,aAAS,0BAAW,aAAa;AACvC,MAAI,WAAW,QAAW;AACxB,UAAM,IAAI;MACR;IAGF;EACF;AACA,aAAO,uBAAQ,MAAM,OAAO,SAAS,IAAI,GAAG,CAAC,QAAQ,IAAI,CAAC;AAC5D;AAsBO,SAAS,iBAGd,MAAoC;AACpC,QAAM,aAAS,0BAAW,aAAa;AACvC,MAAI,WAAW,QAAW;AACxB,UAAM,IAAI;MACR;IAGF;EACF;AACA,aAAO,uBAAQ,MAAM,OAAO,OAAO,IAAI,GAAG,CAAC,QAAQ,IAAI,CAAC;AAC1D;AAkDA,SAAS,4BAA4B,MAAa;AAChD,MAAI,KAAK,WAAW;AAAG;AACvB,QAAM,CAAC,KAAK,IAAI;AAGhB,MACE,OAAO,UAAU,YACjB,UAAU,QACV,aAAa,SACb,aAAa,SACb,wBAAwB,OACxB;AACA,UAAM,IAAI;MACR;IACF;EACF;AACF;",
  "names": ["toByteArray", "fromByteArray", "len", "i", "len2", "value", "Base64", "modification", "fetch", "import_react", "import_react", "import_react", "import_react", "isConvexAuthenticated", "React", "React", "ReactDOM", "currentListeners"]
}
